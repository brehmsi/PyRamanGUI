Index: src/PyRaman.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># author: Simon Brehm\r\nimport io\r\nimport json\r\nimport math\r\nimport matplotlib\r\nimport matplotlib.colors as mcolors\r\nimport matplotlib.patches as mpatches\r\nimport numpy as np\r\nimport operator\r\nimport os\r\nimport pickle\r\nimport prettytable\r\nimport rampy as rp\r\nimport re\r\nimport scipy\r\nimport sympy as sp\r\nimport sys\r\nfrom matplotlib.figure import Figure\r\nfrom matplotlib.backend_bases import MouseEvent\r\nfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg, NavigationToolbar2QT\r\nimport matplotlib.backends.qt_editor.figureoptions as figureoptions\r\nfrom PyQt5 import QtGui, QtWidgets, QtCore\r\nfrom PyQt5.QtGui import QIcon\r\nfrom PyQt5.QtCore import Qt, pyqtSlot\r\nfrom PyQt5.QtWidgets import (QApplication, QMainWindow, QTableWidget, QMessageBox, QCheckBox,\r\n                             QTreeWidgetItem, QTableWidgetItem, QPushButton, QWidget, QMenu,\r\n                             QAction, QDialog, QFileDialog, QAbstractItemView)\r\nfrom matplotlib.backends.qt_editor import _formlayout as formlayout\r\nfrom scipy import sparse, signal, special, stats\r\nfrom scipy.optimize import curve_fit\r\nfrom scipy.sparse.linalg import spsolve\r\nfrom sympy.utilities.lambdify import lambdify\r\nfrom sklearn import decomposition\r\nfrom tabulate import tabulate\r\nfrom pybaselines import whittaker\r\nimport pybaselines\r\n\r\n# Import files\r\nimport myfigureoptions  # see file 'myfigureoptions.py'\r\nimport Database_Measurements  # see file Database_Measurements\r\nfrom BrokenAxes import brokenaxes\r\nimport database_spectra\r\n\r\n# This file essentially consists of four parts:\r\n# 1. Main Window\r\n# 2. Text Window\r\n# 3. Spreadsheet\r\n# 4. Plot\r\n\r\n########################################################################################################################\r\n# 1. Main window\r\n########################################################################################################################\r\n\r\n\r\nclass RamanTreeWidget(QtWidgets.QTreeWidget):\r\n    \"\"\"\r\n    A reimplementation of the PyQt QTreeWidget.\r\n\r\n    the mouseDoubleClickEvent, mousePressEvent, startDrag and DropEvent are modified\r\n\r\n    Attributes\r\n    ----------\r\n    itemDoubleClicked : pyqtSignal\r\n        signal emitted by doubleclick on QTreeWidgetItem\r\n    itemClicked : pyqtSignal\r\n        signal emitted by click on QTreeWidgetItem\r\n    itemDropped : pyqtSignal\r\n        signal emitted by dropping QTreeWidgetItem\r\n    dragged_item : QTreeWidgetItem\r\n        QTreeWidgetItem, which was selected by a mouseclick\r\n\r\n    Methods\r\n    -------\r\n    mouseDoubleClickEvent(event)\r\n        emits signal if QTreeWidgetItem was doubleclicked\r\n    mousePressEvent(event)\r\n        emits signal if QTreeWidgetItem was clicked\r\n    startDrag(action)\r\n        assigns selected QTreeWidgetItem to drag_item\r\n    dropEvent(event)\r\n        emits pyqtSignal if QTreeWidgetItem is dropped\r\n    \"\"\"\r\n    itemDoubleClicked = QtCore.pyqtSignal(object)\r\n    itemClicked = QtCore.pyqtSignal(object, object)\r\n    itemDropped = QtCore.pyqtSignal(object, object)\r\n\r\n    def __init__(self, parent=None):\r\n        \"\"\"\r\n        Parameters\r\n        ----------\r\n        parent : class, optional\r\n            (default is None)\r\n        \"\"\"\r\n        super(RamanTreeWidget, self).__init__(parent)\r\n        self.setDragEnabled(True)\r\n        self.setAcceptDrops(True)\r\n        self.setHeaderHidden(True)\r\n        self.setDropIndicatorShown(True)\r\n        self.setDragDropMode(self.InternalMove)\r\n        self.setSelectionMode(QAbstractItemView.SingleSelection)\r\n\r\n        self.dragged_item = None\r\n\r\n    def mouseDoubleClickEvent(self, event):\r\n        \"\"\"\r\n        Parameters\r\n        ----------\r\n        event : QMouseEvent            #The mouse event.\r\n        \"\"\"\r\n        item = self.itemAt(event.pos())\r\n        if item is not None:\r\n            self.itemDoubleClicked.emit(item)\r\n        else:\r\n            return\r\n\r\n    def mousePressEvent(self, event):\r\n        \"\"\"\r\n        Parameters\r\n        ----------\r\n        event : QMouseEvent           #The mouse event.\r\n        \"\"\"\r\n        item = self.itemAt(event.pos())\r\n        if item is not None:\r\n            self.setCurrentItem(item)\r\n        else:\r\n            pass\r\n        self.itemClicked.emit(event, item)\r\n\r\n        # keep the default behaviour\r\n        super(RamanTreeWidget, self).mousePressEvent(event)\r\n\r\n    def startDrag(self, action):\r\n        \"\"\"\r\n        Parameters\r\n        ----------\r\n        action : Qt.DropAction\r\n        \"\"\"\r\n        self.dragged_item = self.selectedItems()[0]\r\n\r\n        # keep the default behaviour\r\n        super(RamanTreeWidget, self).startDrag(action)\r\n\r\n    def dropEvent(self, event):\r\n        \"\"\"\r\n        Parameters\r\n        ---------\r\n        event : QDropEvent\r\n        \"\"\"\r\n        event.setDropAction(Qt.MoveAction)\r\n        itemAtDropLocation = self.itemAt(event.pos())\r\n\r\n        if itemAtDropLocation is None:\r\n            # no drops outside of folders\r\n            return\r\n        elif itemAtDropLocation != self.dragged_item.parent():\r\n            # send signal if parents (folder) of item changes during drag-drop-event\r\n            self.itemDropped.emit(self.dragged_item, itemAtDropLocation)\r\n\r\n        # keep the default behaviour\r\n        super(RamanTreeWidget, self).dropEvent(event)\r\n\r\n        if self.dragged_item.parent() is None:\r\n            print(\"The item was dropped outside a folder. This will cause some issues\")\r\n            # print(self.dragged_item)\r\n            # print(itemAtDropLocation.childCount())\r\n            itemAtDropLocation.addChild(self.dragged_item)\r\n            itemAtDropLocation.setExpanded(True)\r\n            # print(itemAtDropLocation.childCount())\r\n\r\n\r\nclass MainWindow(QMainWindow):\r\n    \"\"\"\r\n    Creating the main window\r\n    \"\"\"\r\n\r\n    def __init__(self, parent=None):\r\n        super(MainWindow, self).__init__(parent)\r\n        self.window_types = ['Folder', 'Spreadsheet', 'Plotwindow', 'Textwindow']\r\n        self.window = {}  # dictionary with windows\r\n        self.windowWidget = {}\r\n        for j in self.window_types:\r\n            self.window[j] = {}\r\n            self.windowWidget[j] = {}\r\n        self.folder = {}  # key = foldername, value = [Qtreewidgetitem, QmdiArea]\r\n        self.FileName = os.path.dirname(__file__)  # path of this python file\r\n        self.PyramanIcon = QIcon(os.path.dirname(os.path.realpath(__file__)) + \"/Icons/PyRaman_logo.png\")\r\n        self.pHomeRmn = None  # path of Raman File associated to the open project\r\n        self.db_measurements = None\r\n        self.mainWidget = QtWidgets.QSplitter(self)\r\n        self.treeWidget = RamanTreeWidget(self)  # Qtreewidget, to control open windows\r\n        self.tabWidget = QtWidgets.QTabWidget()\r\n        self.statusBar = QtWidgets.QStatusBar()\r\n\r\n        self.create_mainwindow()\r\n\r\n    def create_mainwindow(self):\r\n        \"\"\"\r\n        Create the main window\r\n        \"\"\"\r\n        self.setWindowIcon(self.PyramanIcon)\r\n        self.setWindowTitle('PyRaman')  # set window title\r\n\r\n        # the user can control the size of child widgets by dragging the boundary between them\r\n        self.mainWidget.setHandleWidth(10)\r\n\r\n        self.tabWidget.setTabsClosable(True)\r\n        self.tabWidget.setMovable(True)\r\n        self.tabWidget.tabCloseRequested.connect(self.close_tab)\r\n        self.treeWidget.itemDoubleClicked.connect(self.activate_window)\r\n        self.treeWidget.itemClicked.connect(self.tree_window_options)\r\n        self.treeWidget.itemDropped.connect(self.change_folder)\r\n        self.new_Folder(None)\r\n\r\n        self.mainWidget.addWidget(self.treeWidget)\r\n        self.mainWidget.addWidget(self.tabWidget)\r\n        self.setCentralWidget(self.mainWidget)\r\n\r\n        self.setStatusBar(self.statusBar)\r\n        self.show_statusbar_message('Welcome to PyRaman', 3000)\r\n\r\n        self.create_menubar()\r\n\r\n    def create_menubar(self):\r\n        \"\"\"\r\n        create a menu bar\r\n        \"\"\"\r\n        menu = self.menuBar()\r\n        File = menu.addMenu('File')\r\n        FileNew = File.addMenu('New')\r\n        FileNew.addAction('Spreadsheet', lambda: self.new_window(None, 'Spreadsheet', None, None))\r\n        FileNew.addAction('Textwindow', lambda: self.new_window(None, 'Textwindow', '', None))\r\n        FileNew.addAction('Folder', lambda: self.new_Folder(None))\r\n        File.addAction('Open Project', self.open)\r\n        File.addAction('Save Project As ...', lambda: self.save('Save As'))\r\n        File.addAction('Save Project', lambda: self.save('Save'))\r\n\r\n        medit = menu.addMenu('Edit')\r\n        medit.addAction('Cascade')\r\n        medit.addAction('Tiled')\r\n        medit.triggered[QAction].connect(self.rearange)\r\n\r\n        menu_tools = menu.addMenu('Tools')\r\n        menu_tools.addAction('Database for measurements', self.execute_database_measurements)\r\n\r\n    def show_statusbar_message(self, message, time, error_sound=False):\r\n        self.statusBar.showMessage(message, time)\r\n\r\n    def keyPressEvent(self, event):\r\n        \"\"\"\r\n        A few shortcuts\r\n        \"\"\"\r\n        key = event.key()\r\n        if key == (Qt.Key_Control and Qt.Key_S):\r\n            self.save('Save')\r\n            self.show_statusbar_message('The project was saved', 2000)\r\n        else:\r\n            super(MainWindow, self).keyPressEvent(event)\r\n\r\n    def open(self):\r\n        # Load project in new MainWindow or in existing MW, if empty\r\n        if self.window['Spreadsheet'] == {} and self.window['Plotwindow'] == {}:\r\n            self.load()\r\n        else:\r\n            new_MainWindow()\r\n\r\n    def load(self):\r\n        \"\"\"\r\n        Load project from rmn file with pickle\r\n        @return: None\r\n        \"\"\"\r\n        fileName = QtWidgets.QFileDialog.getOpenFileName(self, 'Load',  # get file name\r\n                                                         self.pHomeRmn, 'All Files (*);;Raman Files (*.rmn)')\r\n\r\n        if fileName[0] != '':  # if fileName is not empty save in pHomeRmn\r\n            self.pHomeRmn = fileName[0]\r\n        else:\r\n            self.close()\r\n            return\r\n\r\n        # open file and save content in variable 'v' with pickle or json\r\n        with open(self.pHomeRmn, 'rb') as file:\r\n            try:\r\n                v = pickle.load(file)\r\n            except pickle.UnpicklingError:\r\n                v = json.load(file)\r\n\r\n        self.treeWidget.clear()\r\n        self.tabWidget.clear()\r\n        self.folder = {}\r\n        for foldername, foldercontent in v.items():\r\n            self.new_Folder(foldername)\r\n            for key, val in foldercontent.items():\r\n                self.new_window(foldername, val[0], val[1], key)\r\n\r\n    def save(self, q):\r\n        \"\"\"\r\n        function to save complete project in json-File\r\n\r\n        Parameters:\r\n        -----------\r\n        q: str\r\n\r\n        \"\"\"\r\n\r\n        # Ask for directory, if none is deposite or 'Save Project As' was pressed\r\n        if self.pHomeRmn is None or q == 'Save As':\r\n            fileName = QtWidgets.QFileDialog.getSaveFileName(self, 'Save as', self.pHomeRmn,\r\n                                                             'All Files (*);;Raman Files (*.rmn)')\r\n            if fileName[0] != '':\r\n                self.pHomeRmn = fileName[0]\r\n            else:\r\n                return\r\n\r\n        save_dict_json = {}\r\n        save_dict = {}\r\n        for key, val in self.folder.items():\r\n            save_dict[key] = {}\r\n            save_dict_json[key] = {}\r\n            for j in range(val[0].childCount()):\r\n                win_name = val[0].child(j).text(0)\r\n                win_type = self.window_types[val[0].child(j).type()]\r\n                window = self.window[win_type][win_name]\r\n\r\n                if win_type == 'Spreadsheet':\r\n                    window_content = window.data\r\n                    window_content_json = window.data.copy()\r\n                    for i in range(len(window_content)):\r\n                        window_content_json[i][\"data\"] = list(window_content_json[i][\"data\"])\r\n                elif win_type == 'Plotwindow':\r\n                    window_content_json = self.get_save_data_plotwindow(window)\r\n                    window_content = [window.data, window.fig]\r\n                elif win_type == 'Textwindow':\r\n                    window_content_json = window.text\r\n                    window_content = window.text\r\n                save_dict[key][win_name] = [win_type, window_content]\r\n                save_dict_json[key][win_name] = [win_type, window_content_json]\r\n\r\n        # save with json\r\n        with open(os.path.splitext(self.pHomeRmn)[0] + \".jrmn\", 'w', encoding='utf-8') as f:\r\n            json.dump(save_dict_json, f, ensure_ascii=False)\r\n\r\n    def get_save_data_plotwindow(self, window):\r\n        \"\"\"Get all data and parameter from plot window and store it in dictionary, which will be saved with json\"\"\"\r\n\r\n        # get data from plotwindow\r\n        data_keys = [\"plot type\", \"label\", \"xaxis\", \"yaxis\", \"filename\", \"spreadsheet title\"]\r\n\r\n        # change all numpy arrays to lists, since \"Object of type ndarray is not JSON serializable\" (TypeError)\r\n        window_data = []\r\n        for i in range(len(window.data)):\r\n            window_data.append({})\r\n            window_data[i][\"x\"] = list(window.data[i][\"x\"])\r\n            window_data[i][\"y\"] = list(window.data[i][\"y\"])\r\n            window_data[i][\"yerr\"] = None\r\n            if isinstance(window.data[i][\"yerr\"], int):\r\n                window.data[i][\"yerr\"] = None\r\n            if window.data[i][\"yerr\"] is not None:\r\n                window_data[i][\"yerr\"] = list(window.data[i][\"yerr\"])\r\n            for dk in data_keys:\r\n                window_data[i][dk] = window.data[i][dk]\r\n\r\n        # necessary for some y data, can be removed later\r\n        for wd in window_data:\r\n            if isinstance(wd[\"y\"][0], np.ndarray):\r\n                wd[\"y\"] = [y[0] for y in wd[\"y\"]]\r\n\r\n        # get all arrows and texts in plot window\r\n        annotations = {\"arrows\": [], \"text\": []}\r\n        for dl in window.drawn_line:\r\n            annotations[\"arrows\"].append({\"posA\": list(dl.posA),\r\n                                          \"posB\": list(dl.posB),\r\n                                          \"style\": dl.arrow_style,\r\n                                          \"head width\": dl.head_width,\r\n                                          \"head length\": dl.head_length,\r\n                                          \"line width\": dl.line_width,\r\n                                          \"line style\": dl.line_style,\r\n                                          \"color\": dl.color})\r\n\r\n        for t in window.inserted_text:\r\n            annotations[\"text\"].append({\"text\": t.text,\r\n                                        \"position\": t.position,\r\n                                        \"font size\": t.font_size,\r\n                                        \"color\": t.color})\r\n\r\n        # get all figure settings\r\n        fig = window.fig\r\n        axes = fig.get_axes()\r\n\r\n        # check if axis is broken\r\n        axis_break = False\r\n        if len(axes) == 1:\r\n            ax, = axes\r\n            ax1 = ax\r\n            axl = ax\r\n        else:\r\n            ax = axes[0]  # main axis\r\n            ax1 = axes[1]  # axis of first segment\r\n            axl = axes[-1]  # axis of last segment\r\n            axis_break = True\r\n\r\n        # get general figure settings\r\n        xticks = ax1.get_xticks()\r\n        yticks = ax1.get_yticks()\r\n\r\n        if xticks.size > 1:\r\n            xtickspace = xticks[1] - xticks[0]\r\n        else:\r\n            xtickspace = None\r\n        if yticks.size > 1:\r\n            ytickspace = yticks[1] - yticks[0]\r\n        else:\r\n            ytickspace = None\r\n\r\n        if 'labelsize' in ax1.xaxis._major_tick_kw:\r\n            _ticksize = int(ax1.xaxis._major_tick_kw['labelsize'])\r\n        else:\r\n            _ticksize = 15\r\n\r\n        axis_options = {\r\n            'axis break': axis_break,\r\n            'x scale': ax1.get_xscale(),\r\n            'x lower limit': ax1.get_xlim()[0],\r\n            'x upper limit': ax1.get_xlim()[1],\r\n            'x tick step size': xtickspace,\r\n            'y scale': ax1.get_yscale(),\r\n            'y lower limit': ax1.get_ylim()[0],\r\n            'y upper limit': ax1.get_ylim()[1],\r\n            'y tick step size': ytickspace\r\n        }\r\n\r\n        if axis_break:\r\n            axis_options[\"x lower limit 2\"] = axl.get_xlim()[0]\r\n            axis_options[\"x upper limit 2\"] = axl.get_xlim()[1]\r\n\r\n        general = {\r\n            'title': ax.get_title(),\r\n            'title font size': int(ax.title.get_fontsize()),\r\n            'label font size': int(ax.xaxis.label.get_fontsize()),\r\n            'tick size': _ticksize,\r\n            'grid': ax.xaxis._major_tick_kw['gridOn'],\r\n            'x label': ax.get_xlabel(),\r\n            'x label pad': ax.xaxis.labelpad,\r\n            'y label': ax.get_ylabel(),\r\n            'y label pad': ax.yaxis.labelpad\r\n        }\r\n\r\n        if ax.legend_ is not None:\r\n            old_legend = ax.get_legend()\r\n            _visible = old_legend._visible\r\n            _draggable = old_legend._draggable is not None\r\n            _ncol = old_legend._ncol\r\n            _fontsize = int(old_legend._fontsize)\r\n            _frameon = old_legend.get_frame_on()\r\n            _shadow = old_legend.shadow\r\n            _fancybox = type(old_legend.legendPatch.get_boxstyle()) == matplotlib.patches.BoxStyle.Round\r\n            _framealpha = old_legend.get_frame().get_alpha()\r\n            _picker = 5\r\n        else:\r\n            _visible = True\r\n            _draggable = False\r\n            _ncol = 1\r\n            _fontsize = 15\r\n            _frameon = True\r\n            _shadow = True\r\n            _fancybox = True\r\n            _framealpha = 0.5\r\n            _picker = 5\r\n\r\n        legend = {\r\n            'visible': _visible,\r\n            'draggable': _draggable,\r\n            'columns': _ncol,\r\n            'font size': _fontsize,\r\n            'frame': _frameon,\r\n            'shadow': _shadow,\r\n            'fancy box': _fancybox,\r\n            'alpha': _framealpha,\r\n            'picker': _picker\r\n        }\r\n\r\n        # get all style elements of curves\r\n        for i, wd in enumerate(window.data):\r\n            if \"line\" in window.data[i].keys():\r\n                if isinstance(window.data[i][\"line\"], dict):\r\n                    wd[\"line options\"] = window.data[i][\"line\"]\r\n                else:\r\n                    line = window.data[i][\"line\"]\r\n                    window.data[i][\"label\"] = line.get_label()\r\n                    window_data[i][\"label\"] = line.get_label()\r\n                    alpha = line.get_alpha()\r\n                    color = mcolors.to_hex(mcolors.to_rgba(line.get_color(), alpha), keep_alpha=True)\r\n                    ec = mcolors.to_hex(mcolors.to_rgba(line.get_markeredgecolor(), alpha), keep_alpha=True)\r\n                    fc = mcolors.to_hex(mcolors.to_rgba(line.get_markerfacecolor(), alpha), keep_alpha=True)\r\n                    curvedata = {\r\n                        'line style': line.get_linestyle(),\r\n                        'draw style': line.get_drawstyle(),\r\n                        'line width': line.get_linewidth(),\r\n                        'color': color,\r\n                        'marker style': line.get_marker(),\r\n                        'marker size': line.get_markersize(),\r\n                        'marker face color': fc,\r\n                        'marker edge color': ec}\r\n                    window_data[i][\"line options\"] = curvedata\r\n\r\n        # get styles for errorbars\r\n        for container in ax1.containers:\r\n            if type(container) == matplotlib.container.ErrorbarContainer:\r\n                plotline, caplines, barlinecols = container\r\n                idx = [window.data.index(wd) for wd in window.data if plotline == wd[\"line\"]]\r\n\r\n                error_color = mcolors.to_hex(\r\n                    mcolors.to_rgba(caplines[0].get_markerfacecolor(), barlinecols[0].get_alpha()), keep_alpha=True)\r\n                window_data[idx[0]][\"line options\"][\"error bar cap size\"] = caplines[0].get_markersize()\r\n                window_data[idx[0]][\"line options\"][\"error bar line width\"] = caplines[0].get_markeredgewidth()\r\n                window_data[idx[0]][\"line options\"][\"error bar color\"] = error_color\r\n\r\n        figure_settings = {\"general\": general, \"axis options\": axis_options, \"legend\": legend}\r\n        save_data = [window_data, {\"figure settings\": figure_settings, \"annotations\": annotations}]\r\n\r\n        return save_data\r\n\r\n    def execute_database_measurements(self):\r\n        title = 'Database'\r\n        self.db_measurements = Database_Measurements.DatabaseMeasurements()\r\n        DBM_tab = self.tabWidget.addTab(self.db_measurements, self.PyramanIcon, title)\r\n\r\n    def create_sidetree_structure(self, structure):\r\n        self.treeWidget.clear()\r\n        for key, val in structure.items():\r\n            self.new_Folder(key)\r\n\r\n    def activate_window(self, item):\r\n        text = item.text(0)\r\n        winTypInt = item.type()  # 0 - Folder, 1 - Spreadsheet, 2 - Plotwindow, 3 - Textwindow\r\n\r\n        if winTypInt == 0:  #\r\n            self.tabWidget.setCurrentWidget(self.folder[text][1])\r\n        else:\r\n            windowtype = self.window_types[winTypInt]\r\n            win = self.windowWidget[windowtype][text]\r\n            currentFolder = item.parent().text(0)\r\n            self.tabWidget.setCurrentWidget(self.folder[currentFolder][1])\r\n            self.folder[currentFolder][1].setActiveSubWindow(win)\r\n            win.showMaximized()\r\n\r\n    def tree_window_options(self, event, tree_item):\r\n        if tree_item is not None:\r\n            if event.button() == QtCore.Qt.RightButton:\r\n                item_text = tree_item.text(0)\r\n                TreeItemMenu = QMenu()\r\n                ActRename = TreeItemMenu.addAction('Rename')\r\n                ActDelete = TreeItemMenu.addAction('Delete')\r\n                ActCopy = TreeItemMenu.addAction('Copy')\r\n                ac = TreeItemMenu.exec_(self.treeWidget.mapToGlobal(event.pos()))\r\n                window_type = self.window_types[tree_item.type()]\r\n\r\n                if ac == ActRename:\r\n                    self.treeWidget.editItem(tree_item)\r\n                    self.treeWidget.itemChanged.connect(lambda item, column:\r\n                                                        self.rename_window(item, column, item_text))\r\n                elif ac == ActDelete:\r\n                    if tree_item.type() == 0:  # if item is folder:\r\n                        self.close_folder(foldername=tree_item.text(0))\r\n                    else:\r\n                        title = tree_item.text(0)\r\n                        self.windowWidget[window_type][title].close()\r\n                elif ac == ActCopy:\r\n                    window_name = tree_item.text(0)\r\n                    window = self.window[window_type][window_name]\r\n                    if window_type == 'Spreadsheet':\r\n                        data = [window_type, window.data.copy()]\r\n                    elif window_type == 'Plotwindow':\r\n                        # no deepcopy of figure possible => create new figure with pickle\r\n                        buf = io.BytesIO()\r\n                        try:\r\n                            pickle.dump(window.fig, buf)\r\n                        except TypeError as e:\r\n                            print(e)\r\n                            print(\"Try to set the legend not-draggable\")\r\n                            return\r\n                        buf.seek(0)\r\n                        fig_copy = pickle.load(buf)\r\n                        data = [window_type, [window.data.copy(), fig_copy]]\r\n                    elif window_type == 'Textwindow':\r\n                        data = [window_type, window.text]\r\n                    else:\r\n                        return\r\n                    folder_name = self.tabWidget.tabText(self.tabWidget.currentIndex())\r\n                    self.new_window(folder_name, data[0], data[1], window_name+\"_Copy\")\r\n        else:\r\n            if event.button() == QtCore.Qt.RightButton:\r\n                TreeItemMenu = QMenu()\r\n                MenuNew = TreeItemMenu.addMenu('&New')\r\n                ActNewFolder = MenuNew.addAction('Folder')\r\n                ActNewSpreadsheet = MenuNew.addAction('Spreadsheet')\r\n                ActNewText = MenuNew.addAction('Text window')\r\n                ac = TreeItemMenu.exec_(self.treeWidget.mapToGlobal(event.pos()))\r\n                # Rename\r\n                if ac == ActNewFolder:\r\n                    self.new_Folder(None)\r\n                elif ac == ActNewSpreadsheet:\r\n                    self.new_window(None, 'Spreadsheet', None, None)\r\n                elif ac == ActNewText:\r\n                    self.new_window(None, 'Textwindow', '', None)\r\n\r\n    def change_folder(self, droppedItem, itemAtDropLocation):\r\n        \"\"\"function is called every time a qtreewidgetitem is dropped\"\"\"\r\n        if itemAtDropLocation.parent() is None:\r\n            new_folder = itemAtDropLocation\r\n        else:\r\n            new_folder = itemAtDropLocation.parent()\r\n        foldername = new_folder.text(0)\r\n        windowtyp = droppedItem.type()\r\n        windowname = droppedItem.text(0)\r\n        if new_folder.type() == 0 and droppedItem.type() != 0:  # dropevent in folder\r\n            previous_folder = droppedItem.parent().text(0)\r\n            self.tabWidget.setCurrentWidget(self.folder[previous_folder][1])\r\n            wind = self.window[self.window_types[windowtyp]][windowname]\r\n            mdi = self.folder[foldername][1]\r\n            new_subwindow = mdi.addSubWindow(wind)\r\n            previous_mdi = self.folder[previous_folder][1]\r\n            previous_mdi.removeSubWindow(wind)\r\n            self.windowWidget[self.window_types[windowtyp]][windowname] = new_subwindow\r\n            self.delete_empty_subwindows(previous_mdi)\r\n        else:\r\n            return\r\n\r\n    def delete_empty_subwindows(self, mdi):\r\n        sub_win_list = mdi.subWindowList()\r\n        for j in sub_win_list:\r\n            if j.widget() is None:\r\n                mdi.removeSubWindow(j)\r\n\r\n    def rename_window(self, item, column, old_text):\r\n        new_text = item.text(column)\r\n        windowtype = self.window_types[item.type()]\r\n\r\n        if new_text == old_text:\r\n            self.show_statusbar_message('Something went wrong', 4000)\r\n            i = 1\r\n            while i <= 100:\r\n                new_text = \"{} {}\".format(windowtype, i)\r\n                if new_text in self.window[windowtype].keys():\r\n                    i += 1\r\n                else:\r\n                    break\r\n            item.setText(0, new_text)\r\n            window_names = []\r\n            for wt in self.window_types:\r\n                window_names.append(self.window[wt].keys())\r\n            window_names = [item for sublist in window_names for item in sublist]\r\n            tree_items_names = []\r\n            for i in range(self.treeWidget.topLevelItemCount()):\r\n                c = self.treeWidget.topLevelItem(i)\r\n                for j in range(c.childCount()):\r\n                    tree_items_names.append(c.child(j).text(0))\r\n            old_text = set(window_names).difference(set(tree_items_names)).pop()\r\n            new_text = set(tree_items_names).difference(set(window_names)).pop()\r\n\r\n        if new_text in self.window[windowtype].keys():  # in case name is already assigned\r\n            try:\r\n                self.treeWidget.itemChanged.disconnect()\r\n            except TypeError as e:\r\n                print(e)\r\n            item.setText(0, old_text)\r\n            self.show_statusbar_message('Name is already assigned', 4000)\r\n        else:\r\n            if windowtype == 'Folder':\r\n                self.folder[new_text] = self.folder.pop(old_text)\r\n                index = self.tabWidget.indexOf(self.folder[new_text][1])\r\n                self.tabWidget.setTabText(index, new_text)\r\n            else:\r\n                try:\r\n                    win = self.windowWidget[windowtype][old_text]\r\n                except KeyError as e:\r\n                    self.treeWidget.itemChanged.disconnect()\r\n                    return\r\n                win.setWindowTitle(new_text)\r\n                self.window[windowtype][new_text] = self.window[windowtype].pop(old_text)\r\n                self.windowWidget[windowtype][new_text] = self.windowWidget[windowtype].pop(old_text)\r\n                self.window[windowtype][new_text].setWindowTitle(new_text)\r\n                self.update_spreadsheet_menubar()\r\n            try:\r\n                self.treeWidget.itemChanged.disconnect()\r\n            except TypeError as e:\r\n                print(e)\r\n\r\n    def rearange(self, q):\r\n        # rearrange open windows\r\n        if q.text() == \"Cascade\":\r\n            self.tabWidget.currentWidget().cascadeSubWindows()\r\n\r\n        if q.text() == \"Tiled\":\r\n            self.tabWidget.currentWidget().tileSubWindows()\r\n\r\n    def create_figure(self, settings_dictionary, data):\r\n        fig = Figure(figsize=(15, 9))\r\n        ax = fig.add_subplot(111)\r\n\r\n        figure_settings = settings_dictionary[\"figure settings\"]\r\n\r\n        # Set general figure settings\r\n        general = figure_settings[\"general\"]\r\n\r\n        ax.set_title(general[\"title\"])\r\n        ax.title.set_fontsize(general[\"title font size\"])\r\n\r\n        ax.set_xlabel(general[\"x label\"])\r\n        ax.xaxis.labelpad = general[\"x label pad\"]\r\n        ax.set_ylabel(general[\"y label\"])\r\n        ax.yaxis.labelpad = general[\"y label pad\"]\r\n        ax.xaxis.label.set_size(general[\"label font size\"])\r\n        ax.yaxis.label.set_size(general[\"label font size\"])\r\n\r\n        axis_option = figure_settings[\"axis options\"]\r\n\r\n        if ax.get_xscale() != axis_option[\"x scale\"]:\r\n            ax.set_xscale(axis_option[\"x scale\"])\r\n        if ax.get_yscale() != axis_option[\"y scale\"]:\r\n            ax.set_yscale(axis_option[\"y scale\"])\r\n\r\n        if axis_option[\"x tick step size\"] is not None:\r\n            x_tick = axis_option[\"x tick step size\"]\r\n            xtick_space_start = math.ceil(axis_option[\"x lower limit\"] / x_tick) * x_tick\r\n            ax.xaxis.set_ticks(np.arange(xtick_space_start, axis_option[\"x upper limit\"], x_tick))\r\n            ax.xaxis.set_ticks(np.arange(xtick_space_start, axis_option[\"x upper limit\"], x_tick))\r\n        ax.set_xlim(axis_option[\"x lower limit\"], axis_option[\"x upper limit\"])\r\n        ax.xaxis.set_tick_params(labelsize=general[\"tick size\"])\r\n\r\n        if axis_option[\"y tick step size\"] is not None:\r\n            y_tick = axis_option[\"y tick step size\"]\r\n            ytick_space_start = math.ceil(axis_option[\"y lower limit\"] / y_tick) * y_tick\r\n            ax.yaxis.set_ticks(np.arange(ytick_space_start, axis_option[\"y upper limit\"], y_tick))\r\n        ax.set_ylim(axis_option[\"y lower limit\"], axis_option[\"y upper limit\"])\r\n        ax.yaxis.set_tick_params(labelsize=general[\"tick size\"])\r\n\r\n        ax.grid(general[\"grid\"])\r\n\r\n        # plot data in figure\r\n        for d in data:\r\n            if d[\"yerr\"] is not None:  # errorbars\r\n                if d[\"plot type\"] is None:\r\n                    d[\"plot type\"] = \"o\"\r\n                (spect, caplines, barlinecol) = ax.errorbar(d[\"x\"], d[\"y\"], yerr=d[\"yerr\"], fmt=d[\"plot type\"],\r\n                                                            picker=True, pickradius=5, capsize=3,\r\n                                                            label=\"_Hidden errorbar {}\".format(d[\"label\"]))\r\n                spect.set_label(d[\"label\"])\r\n                if \"error bar line width\" in d[\"line options\"].keys():\r\n                    dlo = d[\"line options\"]\r\n                    for capline in caplines:\r\n                        capline.set_markersize(dlo[\"error bar cap size\"])\r\n                        capline.set_markeredgewidth(dlo[\"error bar line width\"])\r\n                        capline.set_markerfacecolor(dlo[\"error bar color\"])\r\n                        capline.set_markeredgecolor(dlo[\"error bar color\"])\r\n                    barlinecol[0].set_linewidth(dlo[\"error bar line width\"])\r\n                    barlinecol[0].set_color(dlo[\"error bar color\"])\r\n\r\n            else:\r\n                try:\r\n                    spect, = ax.plot(d[\"x\"], d[\"y\"], d[\"plot type\"], label=d[\"label\"], picker=True, pickradius=5)\r\n                except ValueError as e:\r\n                    print(e)\r\n                    print(d[\"label\"])\r\n                    if d[\"plot type\"] is None:\r\n                        d[\"plot type\"] = \"-\"\r\n                        spect, = ax.plot(d[\"x\"], d[\"y\"], d[\"plot type\"], label=d[\"label\"], picker=True, pickradius=5)\r\n            if \"line options\" in d.keys():\r\n                line_options = d[\"line options\"]\r\n                spect.set_linestyle(line_options[\"line style\"])\r\n                spect.set_drawstyle(line_options[\"draw style\"])\r\n                spect.set_linewidth(line_options[\"line width\"])\r\n                rgba = mcolors.to_rgba(line_options[\"color\"])\r\n                spect.set_alpha(None)\r\n                spect.set_color(rgba)\r\n                if line_options[\"marker style\"] != \"none\":\r\n                    spect.set_marker(line_options[\"marker style\"])\r\n                    spect.set_markersize(line_options[\"marker size\"])\r\n                    spect.set_markerfacecolor(line_options[\"marker face color\"])\r\n                    spect.set_markeredgecolor(line_options[\"marker edge color\"])\r\n            else:\r\n                print(\"no line options in dict\")\r\n            d[\"line\"] = spect\r\n\r\n        if axis_option[\"axis break\"]:\r\n            brokenaxes(xlims=((axis_option[\"x lower limit\"], axis_option[\"x upper limit\"]),\r\n                              (axis_option[\"x lower limit 2\"], axis_option[\"x upper limit 2\"])), fig=fig)\r\n            handles, labels = fig.axes[2].get_legend_handles_labels()\r\n        else:\r\n            handles, labels = ax.get_legend_handles_labels()\r\n\r\n        # Set legend\r\n        legend = figure_settings[\"legend\"]\r\n\r\n        new_legend = ax.legend(handles, labels,\r\n                               ncol=legend[\"columns\"],\r\n                               fontsize=float(legend[\"font size\"]),\r\n                               frameon=legend[\"frame\"],\r\n                               shadow=legend[\"shadow\"],\r\n                               framealpha=legend[\"alpha\"],\r\n                               fancybox=legend[\"fancy box\"])\r\n\r\n        new_legend.set_visible(legend[\"visible\"])\r\n        new_legend.set_picker(legend[\"picker\"])\r\n        new_legend.set_draggable(legend[\"draggable\"])\r\n\r\n        # insert text and arrows\r\n        for a in settings_dictionary[\"annotations\"][\"arrows\"]:\r\n            arrow = mpatches.FancyArrowPatch(a[\"posA\"], a[\"posB\"], mutation_scale=10, picker=50)\r\n            arrow.set_linewidth(a[\"line width\"])\r\n            arrow.set_linestyle(a[\"line style\"])\r\n            arrow.set_color(a[\"color\"])\r\n            if a[\"style\"] != '-':\r\n                arrow.set_arrowstyle(a[\"style\"], head_length=a[\"head length\"], head_width=a[\"head width\"])\r\n            else:\r\n                arrow.set_arrowstyle(a[\"style\"])\r\n            arrow.set_figure(fig)\r\n            ax.add_patch(arrow)\r\n\r\n        for t in settings_dictionary[\"annotations\"][\"text\"]:\r\n            ax.annotate(t[\"text\"], t[\"position\"], picker=True, fontsize=t[\"font size\"], color=t[\"color\"])\r\n        return fig\r\n\r\n    def new_window(self, foldername, windowtype, windowcontent, title):\r\n        if foldername is None:\r\n            foldername = self.tabWidget.tabText(self.tabWidget.currentIndex())\r\n            if foldername == 'Database':\r\n                self.show_statusbar_message('please open window in other folder', 4000)\r\n                return\r\n\r\n        if title is None:\r\n            i = 1\r\n            while i <= 100:\r\n                title = windowtype + ' ' + str(i)\r\n                if title in self.window[windowtype].keys():\r\n                    i += 1\r\n                else:\r\n                    break\r\n\r\n        if windowtype == 'Spreadsheet':\r\n            if windowcontent is None:\r\n                ssd = windowcontent\r\n            else:\r\n                # change old data format to new format\r\n                if isinstance(windowcontent, dict):\r\n                    ssd = []\r\n                    for key, val in windowcontent.items():\r\n                        ssd.append(\r\n                            dict(data=np.array(val[0]), shortname=val[1], type=val[2], filename=val[3], longname=None,\r\n                                 unit=None, comments=None, formula=None))\r\n                else:\r\n                    ssd = windowcontent\r\n                    for i in range(len(ssd)):\r\n                        ssd[i][\"data\"] = np.array(ssd[i][\"data\"])\r\n\r\n            windowtypeInt = 1\r\n            self.window[windowtype][title] = SpreadSheetWindow(ssd, parent=self)\r\n            newSS = self.window[windowtype][title]\r\n            newSS.new_pw_signal.connect(lambda: self.new_window(None, 'Plotwindow', [newSS.plot_data, None], None))\r\n            newSS.add_pw_signal.connect(lambda pw_name: self.add_Plot(pw_name, newSS.plot_data))\r\n            icon = QIcon(os.path.dirname(os.path.realpath(__file__)) + \"/Icons/Icon_spreadsheet.png\")\r\n        elif windowtype == 'Plotwindow':\r\n            windowtypeInt = 2\r\n            plotData, fig = windowcontent\r\n\r\n            if isinstance(fig, dict):\r\n                fig = self.create_figure(fig, plotData)\r\n\r\n            if not plotData:\r\n                self.show_statusbar_message(\"Please select the columns you want to plot!\", 4000)\r\n                return\r\n\r\n            # change old data format to new format\r\n            if not isinstance(plotData[0], dict):\r\n                for idx, pd in enumerate(plotData):\r\n                    plotData[idx] = {\r\n                        \"x\": pd[0],\r\n                        \"y\": pd[1],\r\n                        \"yerr\": pd[5],\r\n                        \"plot type\": pd[4],\r\n                        \"label\": pd[2],\r\n                        \"xaxis\": None,\r\n                        \"yaxis\": None,\r\n                        \"filename\": pd[3],\r\n                        \"spreadsheet title\": pd[6] if len(pd) > 6 else None\r\n                    }\r\n\r\n            if fig is not None:\r\n                # necessary to avoid weird error:\r\n                # (ValueError: figure size must be positive finite not [ 4.58 -0.09])\r\n                fig.set_size_inches(10, 10)\r\n            self.window[windowtype][title] = PlotWindow(plotData, fig, self)\r\n            self.update_spreadsheet_menubar()\r\n            icon = QIcon(os.path.dirname(os.path.realpath(__file__)) + \"/Icons/Icon_plotwindow.png\")\r\n        elif windowtype == 'Textwindow':\r\n            windowtypeInt = 3\r\n            txt = windowcontent\r\n            self.window[windowtype][title] = TextWindow(self, txt)\r\n            icon = QIcon(os.path.dirname(os.path.realpath(__file__)) + \"/Icons/Icon_textwindow.png\")\r\n        else:\r\n            return\r\n\r\n        self.windowWidget[windowtype][title] = self.folder[foldername][1].addSubWindow(self.window[windowtype][title])\r\n        self.window[windowtype][title].setWindowTitle(title)\r\n        self.window[windowtype][title].show()\r\n\r\n        item = QTreeWidgetItem([title], type=windowtypeInt)\r\n        item.setIcon(0, icon)\r\n        item.setFlags(Qt.ItemIsEnabled | Qt.ItemIsEditable | Qt.ItemIsSelectable | Qt.ItemIsDragEnabled |\r\n                      Qt.ItemIsUserCheckable)\r\n\r\n        self.folder[foldername][0].addChild(item)\r\n        self.window[windowtype][title].closeWindowSignal.connect(self.close_window)\r\n\r\n    def new_Folder(self, title):\r\n        if title is None:\r\n            i = 1\r\n            while i <= 100:\r\n                title = 'Folder ' + str(i)\r\n                if title in self.folder.keys():\r\n                    i += 1\r\n                else:\r\n                    break\r\n\r\n        self.folder[title] = []  # first entry contains QTreeWidgetItem (Folder), second contains QMdiArea\r\n        self.folder[title].append(QTreeWidgetItem([title]))\r\n        self.folder[title][0].setFlags(Qt.ItemIsEnabled | Qt.ItemIsEditable | Qt.ItemIsSelectable |\r\n                                       Qt.ItemIsDragEnabled | Qt.ItemIsDropEnabled)\r\n        self.folder[title][0].setIcon(0, QIcon(os.path.dirname(os.path.realpath(__file__)) + \"/Icons/folder.png\"))\r\n        self.treeWidget.addTopLevelItem(self.folder[title][0])\r\n        self.treeWidget.expandItem(self.folder[title][0])\r\n        self.folder[title].append(QtWidgets.QMdiArea(self))  # widget for multi document interface area\r\n        self.tabWidget.addTab(self.folder[title][1], self.PyramanIcon, title)\r\n\r\n    def add_Plot(self, pw_name, plotData):\r\n        \"\"\" add spectrum to existing plotwindow \"\"\"\r\n        for j in plotData:\r\n            j[4] = self.window['Plotwindow'][pw_name].data[0][\"line\"].get_linestyle()\r\n        self.window['Plotwindow'][pw_name].add_plot(plotData)\r\n\r\n    def close_window(self, windowtype, title):\r\n        del self.window[windowtype][title]\r\n        del self.windowWidget[windowtype][title]\r\n        items = self.treeWidget.findItems(title, Qt.MatchFixedString | Qt.MatchRecursive)\r\n\r\n        self.folder[items[0].parent().text(0)][0].removeChild(items[0])\r\n        self.update_spreadsheet_menubar()\r\n\r\n    def close_folder(self, foldername):\r\n        # self.folder\r\n        # key = foldername, value = [Qtreewidgetitem, QmdiArea]\r\n\r\n        # Close all windows in the folder\r\n        self.folder[foldername][1].closeAllSubWindows()\r\n\r\n        # Close tab\r\n        idx = self.tabWidget.indexOf(self.folder[foldername][1])\r\n        self.tabWidget.removeTab(idx)\r\n\r\n        # Remove TreewidgetItem\r\n        root = self.treeWidget.invisibleRootItem()\r\n        root.removeChild(self.folder[foldername][0])\r\n\r\n        # delete dictionary entry in self.folder\r\n        del self.folder[foldername]\r\n\r\n    def close_tab(self, index):\r\n        if self.tabWidget.widget(index) == self.db_measurements:\r\n            self.tabWidget.removeTab(index)\r\n        else:\r\n            for key, val in self.folder.items():\r\n                if val[1] == self.tabWidget.widget(index):\r\n                    self.close_folder(key)\r\n                    break\r\n\r\n    def update_spreadsheet_menubar(self):\r\n        for j in self.window['Spreadsheet'].values():\r\n            j.update_menubar()\r\n\r\n    def closeEvent(self, event):\r\n        # close mainwindow\r\n        close = QMessageBox()\r\n        close.setWindowTitle('Quit')\r\n        close.setText(\"You sure?\")\r\n        close.setStandardButtons(QMessageBox.Yes | QMessageBox.Cancel)\r\n        close = close.exec_()\r\n\r\n        if close == QMessageBox.Yes:\r\n            event.accept()\r\n        else:\r\n            event.ignore()\r\n\r\n\r\n########################################################################################################################\r\n# 2. Text - Window\r\n########################################################################################################################\r\n\r\nclass TextWindow(QMainWindow):\r\n    closeWindowSignal = QtCore.pyqtSignal(str, str)\r\n\r\n    def __init__(self, mainwindow, text, parent=None):\r\n        super(TextWindow, self).__init__(parent)\r\n        self.text = text\r\n        self.mw = mainwindow\r\n\r\n        self.create_textwidget()\r\n        self.create_menubar()\r\n\r\n    def create_textwidget(self):\r\n        self.textfield = QtWidgets.QPlainTextEdit()\r\n        self.textfield.setPlainText(self.text)\r\n        self.textfield.createStandardContextMenu()\r\n        self.textfield.setUndoRedoEnabled(True)\r\n        self.textfield.setShortcutEnabled(True)\r\n        self.setCentralWidget(self.textfield)\r\n        self.textfield.textChanged.connect(self.text_change)\r\n\r\n    def create_menubar(self):\r\n        # create the menubar\r\n        self.menubar = self.menuBar()\r\n\r\n        # 1. Menu item: File\r\n        fileMenu = self.menubar.addMenu('&File')\r\n        fileMenu.addAction('Save Text', self.file_save)\r\n        fileMenu.addAction('Load Text', self.load_file)\r\n\r\n        # 2. Menu item: Edit\r\n        # editMenu = self.menubar.addMenu('&Edit')\r\n\r\n        self.show()\r\n\r\n    def text_change(self):\r\n        self.text = self.textfield.toPlainText()\r\n\r\n    def file_save(self):\r\n        fileName = QtWidgets.QFileDialog.getSaveFileName(self, 'Load', filter='All Files (*);; Txt Files (*.txt)')\r\n\r\n        if fileName[0] != '':\r\n            fileName = fileName[0]\r\n        else:\r\n            return\r\n\r\n        file = open(fileName, 'w')\r\n        try:\r\n            file.write(self.text)\r\n        except UnicodeEncodeError as e:\r\n            self.mw.show_statusbar_message(''.format(e), 4000)\r\n        file.close()\r\n\r\n    def load_file(self):\r\n        fileName = QtWidgets.QFileDialog.getOpenFileName(self, 'Load', filter='All Files (*);; Txt Files (*.txt)')\r\n\r\n        if fileName[0] != '':\r\n            fileName = fileName[0]\r\n        else:\r\n            return\r\n\r\n        file = open(fileName, 'rb')\r\n        bintext = file.read()\r\n        file.close()\r\n\r\n        self.text = bintext.decode(\"utf-8\")\r\n        self.textfield.setPlainText(self.text)\r\n\r\n    def closeEvent(self, event):\r\n        close = QMessageBox()\r\n        close.setWindowTitle('Quit')\r\n        close.setText(\"You sure?\")\r\n        close.setStandardButtons(QMessageBox.Yes | QMessageBox.Cancel)\r\n        close = close.exec_()\r\n\r\n        if close == QMessageBox.Yes:\r\n            self.closeWindowSignal.emit('Textwindow', self.windowTitle())\r\n            event.accept()\r\n        else:\r\n            event.ignore()\r\n\r\n\r\n########################################################################################################################\r\n# 3. Spreadsheet\r\n########################################################################################################################\r\n\r\nclass FormulaInterpreter:\r\n    \"\"\"\r\n    class to analyse formulas typed in the formula field of the Spreadsheet header\r\n    written by Christopher Tao\r\n    source: https://levelup.gitconnected.com/how-to-write-a-formula-string-parser-in-python-5362210afeab\r\n    \"\"\"\r\n    def __init__(self, data):\r\n        self.data = data\r\n        self.ops = {\r\n            \"+\": operator.add,\r\n            \"-\": operator.sub,\r\n            \"*\": operator.mul,\r\n            \"/\": operator.truediv}\r\n\r\n    def interprete_formula(self, f):\r\n        if re.match(r'\\ACol\\([0-9]+\\)\\Z', f):\r\n            col_formula = int(re.findall(r'\\b\\d+\\b', f)[0])\r\n            return self.data[col_formula]['data']\r\n        elif re.match(r'\\A\\(.+\\)\\Z', f) and self.parentheses_enclosed(f):  # e.g. '(Col(1)-Col(2))'\r\n            return self.interprete_formula(f[1:-1])\r\n        elif f.replace('.', '', 1).isdigit():                               # constant numbers: e.g. '2+3*Col(0)'\r\n            return float(f)\r\n        elif '+' in f or '-' in f or '*' in f or '/' in f:\r\n            rest_f = self.remove_matched_parentheses(f)\r\n            # not combine it with '+' and '-' because  multiplication and division first, then addition and subtraction\r\n            if '+' in rest_f or '-' in rest_f:\r\n                split_f = re.compile(r'[\\+\\-]').split(f)\r\n            else:\r\n                split_f = re.compile(r'[\\*\\/]').split(f)\r\n\r\n            if split_f[0].count('(') != split_f[0].count(')'):\r\n                nested_level = split_f[0].count('(') - split_f[0].count(')')\r\n                pos = len(split_f[0])\r\n                for sf in split_f[1:]:\r\n                    if '(' in sf:\r\n                        nested_level += sf.count('(')\r\n                    if ')' in sf:\r\n                        nested_level -= sf.count(')')\r\n                    pos += len(sf) + 1  # +1 because of the operator inside parenthesis\r\n                    if nested_level == 0:\r\n                        break\r\n            else:\r\n                pos = len(split_f[0])\r\n\r\n            left = f[:pos]          # left component\r\n            right = f[pos + 1:]     # right component\r\n            op = f[pos]             # the operator\r\n            return self.ops[op](self.interprete_formula(left), self.interprete_formula(right))\r\n        else:\r\n            print('There is something wrong with the formula')\r\n            return np.full(len(self.data[0]['data']), 0)\r\n\r\n    def parentheses_enclosed(self, s):\r\n        paren_order = re.findall(r'[\\(\\)]', s)\r\n\r\n        if paren_order.count('(') != paren_order.count(')'):\r\n            return False\r\n\r\n        curr_levels = []\r\n        nest_lv = 0\r\n        for p in paren_order:\r\n            if p == '(':\r\n                nest_lv += 1\r\n            else:\r\n                nest_lv -= 1\r\n            curr_levels.append(nest_lv)\r\n        if 0 in curr_levels[:-1]:\r\n            return False\r\n        else:\r\n            return True\r\n\r\n    def remove_matched_parentheses(self, formula):\r\n        if re.search(r\"(?<!Col)\\(\", formula):\r\n            match_end_par = re.search(r\"(?<!Col\\(\\d)\\)\", formula)\r\n            end_par = match_end_par.start()  # index of first ')'\r\n            start_par = [m.start() for m in re.finditer(r\"(?<!Col)\\(\", formula[:end_par])][-1] # index of last '('\r\n            return self.remove_matched_parentheses(formula[:start_par] + formula[end_par + 1:])\r\n        else:\r\n            return formula\r\n\r\n\r\nclass RamanSpreadSheet(QTableWidget):\r\n    \"\"\" A reimplementation of the QTableWidget\"\"\"\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        super(RamanSpreadSheet, self).__init__(*args, **kwargs)\r\n        self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)\r\n        self.horizontalHeader().hide()\r\n        self.p = self.parent()\r\n        self.setFrameStyle(0)\r\n        self.setViewportMargins(0, 0, 0, 0)\r\n\r\n    def resizeEvent(self, event):\r\n        width = self.p.header_table.verticalHeader().width()\r\n        self.verticalHeader().setFixedWidth(width)\r\n        # keep the default behaviour\r\n        super(RamanSpreadSheet, self).resizeEvent(event)\r\n\r\n\r\nclass Header(QTableWidget):\r\n    \"\"\" A reimplementation of the QTableWidget to use it as multi-row header\"\"\"\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        super(Header, self).__init__(*args, **kwargs)\r\n        self.p = self.parent()\r\n        row_height = self.rowHeight(0)\r\n        row_count = self.rowCount()\r\n        header_height = self.horizontalHeader().height()\r\n        self.setFixedHeight(row_height * row_count + header_height)\r\n        self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\r\n        self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\r\n        self.setFrameStyle(0)\r\n\r\n        self.setSizePolicy(QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum))\r\n        self.setVerticalHeaderLabels(['Name', 'Axis', 'Unit', 'Comments', 'F(x)='])\r\n        hh = self.horizontalHeader()\r\n        hh.sectionResized.connect(self.section_resized)\r\n        hh.selectionModel().selectionChanged.connect(self.section_selected)\r\n\r\n    def section_resized(self, idx, old_size, new_size):\r\n        self.p.data_table.setColumnWidth(idx, new_size)\r\n\r\n    def section_selected(self):\r\n        idx = sorted(set(i.column() for i in self.selectedIndexes()))\r\n        for i in idx:\r\n            self.p.data_table.selectColumn(i)\r\n\r\n\r\nclass SpreadSheetWindow(QMainWindow):\r\n    \"\"\"\r\n    creates QMainWindow containing the spreadsheet\r\n    \"\"\"\r\n    new_pw_signal = QtCore.pyqtSignal()\r\n    add_pw_signal = QtCore.pyqtSignal(str)\r\n    closeWindowSignal = QtCore.pyqtSignal(str, str)\r\n\r\n    def __init__(self, data, parent):\r\n        super(SpreadSheetWindow, self).__init__(parent)\r\n        # structure of self.data (dictionary):\r\n        # {'dataX with X = (0,1,2,..)' : data,'short name', 'X, Y or Yerr', if loaded: 'filename', 'Long Name',\r\n        # 'Axis Label', 'Unit', 'Comments')\r\n\r\n        if data is None:\r\n            self.data = [self.create_data(np.full(9, np.nan), shortname=\"A\", type=\"X\"),\r\n                         self.create_data(np.full(9, np.nan), shortname=\"B\", type=\"Y\")]\r\n        else:\r\n            self.data = data\r\n        self.mw = parent\r\n        self.cols = len(self.data)  # number of columns\r\n        if not self.data:\r\n            self.rows = 0\r\n        else:\r\n            self.rows = max([len(d[\"data\"]) for d in self.data])  # number of rows\r\n        self.pHomeTxt = None  # path of Txt-File\r\n\r\n        self.central_widget = QWidget()\r\n        self.header_table = Header(5, self.cols, parent=self)  # table header\r\n        self.data_table = RamanSpreadSheet(self.rows, self.cols, parent=self)  # table widget\r\n\r\n        # Layout of tables\r\n        self.main_layout = QtWidgets.QBoxLayout(QtWidgets.QBoxLayout.TopToBottom, self.central_widget)\r\n        self.main_layout.setContentsMargins(0, 0, 0, 0)\r\n        header_layout = QtWidgets.QHBoxLayout()\r\n        header_layout.addWidget(self.header_table)\r\n        header_layout.addSpacing(21)  # to level with vertical scrollbar from data table\r\n        self.main_layout.setSpacing(0)\r\n        self.main_layout.setAlignment(Qt.AlignTop)\r\n        self.main_layout.addLayout(header_layout)\r\n        self.main_layout.addWidget(self.data_table)\r\n\r\n        self.setCentralWidget(self.central_widget)\r\n\r\n        # connect scrollbar from data table with header table\r\n        self.data_table.horizontalScrollBar().valueChanged.connect(self.header_table.horizontalScrollBar().setValue)\r\n\r\n        self.create_table_items()\r\n        self.create_header_items(start=0, end=self.cols)\r\n        self.create_menubar()\r\n        self.create_col_header()\r\n        self.create_row_header()\r\n\r\n    def create_data(self, data_content, shortname=\"A\", type=\"Y\", filename=None):\r\n        data_dict = {\"data\": data_content,\r\n                     \"shortname\": shortname,\r\n                     \"type\": type,\r\n                     \"filename\": filename,\r\n                     \"longname\": None,\r\n                     \"axis label\": None,\r\n                     \"unit\": None,\r\n                     \"comments\": None,\r\n                     \"formula\": None}\r\n        return data_dict\r\n\r\n    def create_table_items(self):\r\n        \"\"\" fill the table items with data \"\"\"\r\n        for c in range(self.cols):\r\n            for r in range(len(self.data[c][\"data\"])):\r\n                cell = QTableWidgetItem(str(self.data[c][\"data\"][r]))\r\n                self.data_table.setItem(r, c, cell)\r\n        self.data_table.itemChanged.connect(self.update_data)\r\n\r\n    def create_header_items(self, start, end):\r\n        for c in range(start, end):\r\n            for r, key in enumerate([\"longname\", \"axis label\", \"unit\", \"comments\", \"formula\"]):\r\n                try:\r\n                    item_text = self.data[c][key]\r\n                except KeyError:\r\n                    item_text = None\r\n                    self.data[c][key] = None\r\n                header_item = QTableWidgetItem(item_text)\r\n                header_item.setBackground(QtGui.QColor(255, 255, 200))  # color: light yellow\r\n                self.header_table.setItem(r, c, header_item)\r\n        self.header_table.itemChanged.connect(self.update_header)\r\n\r\n    def create_menubar(self):\r\n        \"\"\" create the menubar \"\"\"\r\n        self.menubar = self.menuBar()\r\n\r\n        # 1. menu item: File\r\n        fileMenu = self.menubar.addMenu('&File')\r\n        fileMenu.addAction('Save Data', self.file_save)\r\n        fileMenu.addAction('Load Data', self.load_file)\r\n\r\n        # 2. menu item: Edit\r\n        editMenu = self.menubar.addMenu('&Edit')\r\n        editMenu.addAction('New Column', self.new_col)\r\n        editMenu.addAction(\"Select all X columns\", self.select_all_X)\r\n\r\n        # 3. menu item: Plot\r\n        plotMenu = self.menubar.addMenu('&Plot')\r\n        plotNew = plotMenu.addMenu('&New')\r\n        plotNew.addAction('Line Plot', self.get_plot_data)\r\n        plotNew.addAction('Dot Plot', self.get_plot_data)\r\n        plotAdd = plotMenu.addMenu('&Add to')\r\n        for j in self.mw.window['Plotwindow'].keys():\r\n            plotAdd.addAction(j, self.get_plot_data)\r\n        plotMenu.addAction('Plot all', lambda: self.get_plot_data(plot_all=True))\r\n\r\n        # 4. menu item: Analysis\r\n        analysis_menu = self.menubar.addMenu(\"&Analysis\")\r\n        analysis_menu.addAction(\"Principal component analysis\", self.pca_nmf)\r\n        analysis_menu.addAction(\"Non-negative matrix factorization\", self.pca_nmf)\r\n\r\n        self.show()\r\n\r\n    def update_menubar(self):\r\n        self.menubar.clear()\r\n        self.create_menubar()\r\n\r\n    def create_col_header(self):\r\n        headers = ['{} ({})'.format(d['shortname'], d['type']) for d in self.data]\r\n\r\n        self.header_table.setHorizontalHeaderLabels(headers)\r\n\r\n        # open header_menu with right mouse click\r\n        self.headers = self.header_table.horizontalHeader()\r\n        self.headers.setContextMenuPolicy(Qt.CustomContextMenu)\r\n        self.headers.customContextMenuRequested.connect(self.show_header_context_menu)\r\n        self.headers.setSelectionMode(QAbstractItemView.SingleSelection)\r\n\r\n        # opens rename_header with double mouse click\r\n        self.headerline = QtWidgets.QLineEdit()  # Create\r\n        self.headerline.setWindowFlags(QtCore.Qt.FramelessWindowHint)  # Hide title bar\r\n        self.headerline.setAlignment(QtCore.Qt.AlignLeft)  # Set the Alignmnet\r\n        self.headerline.setHidden(True)  # Hide it till its needed\r\n        self.sectionedit = 0\r\n        self.header_table.horizontalHeader().sectionDoubleClicked.connect(self.rename_header)\r\n\r\n    def rename_header(self, logical_column):\r\n        # This block sets up the geometry for the line edit\r\n        header_position = self.headers.mapToGlobal(QtCore.QPoint(0, 0))\r\n        edit_geometry = self.headerline.geometry()\r\n        edit_geometry.setWidth(self.headers.sectionSize(logical_column))\r\n        edit_geometry.setHeight(self.header_table.rowHeight(0))\r\n        edit_geometry.moveLeft(header_position.x() + self.headers.sectionViewportPosition(logical_column))\r\n        edit_geometry.moveTop(header_position.y())\r\n        self.headerline.setGeometry(edit_geometry)\r\n        visual_column = self.data_table.visualColumn(logical_column)\r\n        handler = self.headerline.editingFinished.connect(lambda: self.header_editing_finished(logical_column,\r\n                                                                                               visual_column, handler))\r\n\r\n        self.headerline.setText(self.data[visual_column]['shortname'])\r\n        self.headerline.setHidden(False)  # Make it visible\r\n        self.headerline.setFocus()\r\n\r\n    def header_editing_finished(self, log_col, vis_col, handler):\r\n        try:\r\n            self.headerline.editingFinished.disconnect(handler)\r\n        except Exception:\r\n            return\r\n        self.headerline.setHidden(True)\r\n        newHeader = str(self.headerline.text())\r\n        self.data[vis_col][\"shortname\"] = newHeader\r\n        self.header_table.horizontalHeaderItem(log_col).setText(\r\n            '{} ({})'.format(self.data[vis_col][\"shortname\"], self.data[vis_col][\"type\"]))\r\n\r\n    def show_header_context_menu(self, position):\r\n        selected_column = self.headers.logicalIndexAt(position)\r\n        header_menu = QMenu()\r\n        plot_data = header_menu.addMenu(\"Plot data\")\r\n        plot_data.addAction(\"Line Plot\", self.get_plot_data)\r\n        plot_data.addAction(\"Dot Plot\", self.get_plot_data)\r\n        delete_column = header_menu.addAction('Delete this column')\r\n        set_xy = header_menu.addMenu('Set as:')\r\n        set_xy.addAction('X')\r\n        set_xy.addAction('Y')\r\n        set_xy.addAction('Yerr')\r\n        set_xy.triggered[QAction].connect(lambda QAction: self.set_column_type(QAction, selected_column))\r\n        convert_unit = header_menu.addMenu(\"convert unit\")\r\n        convert_unit.addAction(\"cm^-1 to nm\")\r\n        convert_unit.addAction(\"nm to cm^-1\")\r\n        convert_unit.triggered[QAction].connect(lambda QAction: self.convert_column_unit(QAction, selected_column))\r\n        header_menu.addAction(\"Flip column\", lambda: self.flip_column(selected_column))\r\n        mov_col = header_menu.addMenu(\"Move column\")\r\n        mov_col.addAction('Move left')\r\n        mov_col.addAction('Move right')\r\n        mov_col.addAction('Move to first')\r\n        mov_col.addAction('Move to last')\r\n        mov_col.triggered[QAction].connect(lambda QAction: self.move_column(QAction, selected_column))\r\n        ac = header_menu.exec_(self.header_table.mapToGlobal(position))\r\n        # Delete selected colums\r\n        if ac == delete_column:\r\n            # Get the index of all selected columns in reverse order, so that last column is deleted first\r\n            selCol = sorted(set(index.column() for index in self.header_table.selectedIndexes()), reverse=True)\r\n            for j in selCol:\r\n                del self.data[j]  # Delete data\r\n                self.data_table.removeColumn(j)  # Delete column\r\n                self.header_table.removeColumn(j)\r\n                self.cols = self.cols - 1\r\n\r\n    def convert_column_unit(self, action, selected_column):\r\n        dialog_wavelength = QDialog()\r\n        layout = QtWidgets.QGridLayout()\r\n        cbox = QtWidgets.QComboBox()\r\n        cbox.addItem(\"325\")\r\n        cbox.addItem(\"442\")\r\n        cbox.addItem(\"532\")\r\n        cbox.addItem(\"633\")\r\n        cbox.addItem(\"785\")\r\n        layout.addWidget(cbox)\r\n        dialog_wavelength.setLayout(layout)\r\n        dialog_wavelength.setWindowTitle(\"Select a Wavelength\")\r\n        dialog_wavelength.setWindowModality(Qt.ApplicationModal)\r\n        dialog_wavelength.exec_()\r\n        wl0 = cbox.currentText()\r\n        if action.text() == \"cm^-1 to nm\":\r\n            unit_text = \"nm\"\r\n            formula = f\"{wl0}/(1-Col({selected_column})*0.0000001*{wl0})\"\r\n\r\n        elif action.text() == \"nm to cm^-1\":\r\n            unit_text = \"cm^-1\"\r\n            formula = f\"((1/{wl0})-(1/Col({selected_column})))*10000000\"\r\n\r\n        self.header_table.item(2, selected_column).setText(unit_text)\r\n        self.header_table.item(4, selected_column).setText(formula.format(wl0=wl0, selected_column=selected_column))\r\n\r\n    def flip_column(self, selected_column):\r\n        \"\"\"\r\n        flip the selected column\r\n        @param selected_column: logical index of selected column\r\n        @return:\r\n        \"\"\"\r\n        selected_column = self.header_table.visualColumn(selected_column)\r\n        self.data[selected_column][\"data\"] = np.flip(self.data[selected_column][\"data\"])\r\n        self.create_table_items()\r\n\r\n    def select_all_X(self):\r\n        for c in range(self.cols):\r\n            if self.data[c][\"type\"]==\"X\":\r\n                self.header_table.item(0, c).setSelected(True)\r\n\r\n    def pca_nmf(self):\r\n        \"\"\"principal component analysis with all selected y values\"\"\"\r\n        selected_columns = sorted(set(self.headers.visualIndex(idx.column()) for idx in\r\n                                      self.header_table.selectedIndexes()))\r\n        y_all = []\r\n        # get all data\r\n        for n in selected_columns:\r\n            if self.data[n][\"type\"] != 'Y':\r\n                self.mw.show_statusbar_message('Please only select Y-columns!', 4000)\r\n                return\r\n\r\n            ys = self.data[n][\"data\"]\r\n            y_all.append(ys)\r\n\r\n        # check if all have same length\r\n        y_it = iter(y_all)\r\n        len_y = len(next(y_it))\r\n        if not all(len(l) == len_y for l in y_it):\r\n            self.mw.show_statusbar_message(\"Data has to have same length!\", 4000)\r\n            return\r\n\r\n        n_comp, ok = QtWidgets.QInputDialog().getInt(self, \"Number of components\", \"Number of components\", value=2,\r\n                                                     min=2, max=len(y_all), step=1)\r\n        # stack all y data\r\n        all_samples = np.stack(y_all, axis=0)\r\n\r\n        action_text = self.sender().text()\r\n        if action_text == \"Principal component analysis\":\r\n            # do the PCA analysis\r\n            pca = decomposition.PCA(n_components=n_comp)\r\n            y_transformed = pca.fit_transform(all_samples.T).T\r\n            analysis_name = \"PCA\"\r\n        elif action_text == \"Non-negative matrix factorization\":\r\n            # do the NMF analysis\r\n            nmf = decomposition.NMF(n_components=n_comp)\r\n            y_transformed = nmf.fit_transform(all_samples.T).T\r\n            analysis_name = \"NMF\"\r\n\r\n        # insert data in table\r\n        for idx, y_i in enumerate(y_transformed):\r\n            self.new_col(data_content=y_i, short_name=\"{} {}\".format(analysis_name, idx+1))\r\n\r\n    def set_column_type(self, qaction, log_col):\r\n        \"\"\"\r\n        setting the column type to X, Y or Yerr\r\n        @param qaction:\r\n        @param log_col: logical index of selected column\r\n        @return:\r\n        \"\"\"\r\n        col_type = qaction.text()\r\n        vis_col = self.header_table.visualColumn(log_col)\r\n        self.data[vis_col][\"type\"] = col_type\r\n        self.header_table.horizontalHeaderItem(log_col).setText(\r\n            \"{}({})\".format(self.data[vis_col][\"shortname\"], col_type))\r\n\r\n    def move_column(self, qaction, selected_column):\r\n        old_idx = self.headers.visualIndex(selected_column)\r\n        if qaction.text() == 'Move left':\r\n            new_idx = old_idx - 1\r\n        elif qaction.text() == 'Move right':\r\n            new_idx = old_idx + 1\r\n        elif qaction.text() == 'Move to first':\r\n            new_idx = 0\r\n        elif qaction.text() == 'Move to last':\r\n            new_idx = self.data_table.columnCount() - 1\r\n        self.headers.moveSection(old_idx, new_idx)\r\n        self.data_table.horizontalHeader().moveSection(old_idx, new_idx)\r\n        self.data.insert(new_idx, self.data.pop(old_idx))\r\n\r\n    def create_row_header(self):\r\n        \"\"\"opens header_menu with right mouse click on header\"\"\"\r\n        self.row_headers = self.data_table.verticalHeader()\r\n        self.row_headers.setContextMenuPolicy(Qt.CustomContextMenu)\r\n        self.row_headers.customContextMenuRequested.connect(self.row_options)\r\n        self.row_headers.setSelectionMode(QAbstractItemView.SingleSelection)\r\n\r\n    def row_options(self, position):\r\n        selected_row = self.row_headers.logicalIndexAt(position)\r\n        header_menu = QMenu()\r\n        delete_row = header_menu.addAction('Delete this row')\r\n        ac = header_menu.exec_(self.data_table.mapToGlobal(position))\r\n        # Delete selected colums\r\n        if ac == delete_row:\r\n            # Get the index of all selected rows in reverse order, so that last row is deleted first\r\n            selRow = sorted(set(index.row() for index in self.data_table.selectedIndexes()), reverse=True)\r\n            for c in range(self.cols):\r\n                for r in selRow:\r\n                    try:\r\n                        self.data[c][\"data\"] = np.delete(self.data[c][\"data\"], r)  # Delete data\r\n                    except IndexError as e:\r\n                        print(e)\r\n            for k in selRow:\r\n                self.data_table.removeRow(k)  # Delete row\r\n                self.rows = self.rows - 1\r\n\r\n    def keyPressEvent(self, event):\r\n        # A few shortcuts\r\n        # Enter or Return: go to the next row\r\n        key = event.key()\r\n        if key == Qt.Key_Return or key == Qt.Key_Enter:\r\n            # go to next row\r\n            cr = self.data_table.currentRow()\r\n            cc = self.data_table.currentColumn()\r\n            if cr == (self.rows - 1):\r\n                self.data_table.insertRow(self.rows)\r\n                for i in range(self.cols):\r\n                    self.data_table.setItem(self.rows, i, QTableWidgetItem(''))\r\n                self.rows = self.rows + 1\r\n            else:\r\n                pass\r\n            ti = self.data_table.item(cr + 1, cc)\r\n            self.data_table.setCurrentItem(ti)\r\n        # if key == Qt.Key_Delete:\r\n        #    selItem = [[index.row(), index.column()] for index in self.data_table.selectedIndexes()]\r\n        #    for j in selItem:\r\n        #        self.data_table.takeItem(j[0], j[1])\r\n        #        self.data[j[1]][\"data\"][j[0]] = np.nan\r\n        else:\r\n            super(SpreadSheetWindow, self).keyPressEvent(event)\r\n\r\n    def file_save(self):\r\n        \"\"\"\r\n        save data from spreadsheet in txt-file\r\n        \"\"\"\r\n        SaveFileName = QtWidgets.QFileDialog.getSaveFileName(self, 'Save File', self.pHomeTxt)\r\n\r\n        if SaveFileName[0] != '':\r\n            SaveFileName = SaveFileName[0]\r\n        else:\r\n            return\r\n\r\n        save_data = [self.data[0][\"data\"]]\r\n        header = self.data[0][\"shortname\"]\r\n        for c in range(1, self.cols):\r\n            save_data.append(self.data[c][\"data\"])\r\n            header = '{}%{}'.format(header, self.data[c][\"shortname\"])\r\n        header = '{} '.format(header)\r\n\r\n        n = len(self.data[0][\"data\"])\r\n        if all(len(x) == n for x in save_data):\r\n            pass\r\n        else:\r\n            self.mw.show_statusbar_message('The columns have different lengths!', 4000)\r\n            return\r\n\r\n        save_data = np.transpose(save_data)\r\n\r\n        if SaveFileName[-4:] != '.txt':\r\n            SaveFileName = '{}.txt'.format(SaveFileName)\r\n\r\n        self.pHomeTxt = SaveFileName\r\n\r\n        np.savetxt(SaveFileName, save_data, fmt='%.5f', header=header)\r\n\r\n    def load_file(self):\r\n        \"\"\"\r\n        function to load data from a txt file into the spreadsheet\r\n        \"\"\"\r\n\r\n        # In case there already is data in the spreadsheet, ask if replace or added\r\n        if any(d['filename'] is not None for d in self.data):\r\n            FrageErsetzen = QtWidgets.QMessageBox()\r\n            FrageErsetzen.setIcon(QMessageBox.Question)\r\n            FrageErsetzen.setWindowTitle('Replace or Add?')\r\n            FrageErsetzen.setText('There is already loaded data. Shall it be replaced?')\r\n            buttonY = FrageErsetzen.addButton(QMessageBox.Yes)\r\n            buttonY.setText('Replace')\r\n            buttonN = FrageErsetzen.addButton(QMessageBox.No)\r\n            buttonN.setText('Add')\r\n            buttonC = FrageErsetzen.addButton(QMessageBox.Cancel)\r\n            buttonC.setText('Cancel')\r\n            returnValue = FrageErsetzen.exec_()\r\n            if returnValue == QMessageBox.Yes:  # Replace\r\n                self.data = []\r\n                self.cols = 0\r\n                self.rows = 0\r\n            elif returnValue == QMessageBox.No:  # Add\r\n                pass\r\n            else:  # Cancel\r\n                return\r\n        else:\r\n            self.data = []\r\n            self.cols = 0\r\n            self.rows = 0\r\n\r\n        cols_before = self.cols\r\n        dialog = QFileDialog(self)\r\n        dialog.setFileMode(QFileDialog.ExistingFiles)\r\n        dialog.setNameFilter(\"Data Files (*.txt *.asc *.dat)\")\r\n        dialog.setViewMode(QFileDialog.List)\r\n        dialog.setDirectory(self.pHomeTxt)\r\n        if dialog.exec_():\r\n            newFiles = dialog.selectedFiles()\r\n        else:\r\n            return\r\n\r\n        n_newFiles = len(newFiles)\r\n        load_data = []\r\n        lines = []\r\n        FileName = []\r\n        header = []\r\n        for j in range(n_newFiles):\r\n            # read first line to get header\r\n            with open(newFiles[j]) as f:\r\n                try:\r\n                    firstline = f.readline()\r\n                except UnicodeDecodeError as e:\r\n                    print(e, newFiles[j])\r\n                    n_newFiles -= 1\r\n                    continue\r\n            # check if file has a header (starts with #)\r\n            if firstline[0] == '#':\r\n                firstline = firstline[1:-2]  # remove '#' at beginning and '\\n' at end\r\n                firstline = firstline.split('%')  # headers of different columns are seperated by '%'\r\n                header.append(firstline)\r\n            else:\r\n                header.append(None)\r\n\r\n            try:\r\n                load_data.append(np.loadtxt(newFiles[j]))\r\n                # load_data.append(np.genfromtxt(newFiles[j], missing_values='', filling_values=''))\r\n            except Exception as e:\r\n                self.mw.show_statusbar_message(\"The file couldn't be imported\", 4000)\r\n                print('{} \\nThe file could not be imported, maybe the columns have different lengths'.format(e))\r\n                return\r\n\r\n            try:\r\n                load_data[j] = np.transpose(load_data[j])\r\n            except IndexError as e:\r\n                print(\"The data format is not readabel for PyRaman\\n\", e)\r\n                return\r\n\r\n            if isinstance(load_data[j][0], float):\r\n                load_data[j] = [load_data[j], np.ones(len(load_data[j])) * np.nan]\r\n\r\n            lines.append(len(load_data[j]))\r\n            FileName.append(os.path.splitext(os.path.basename(newFiles[j]))[0])\r\n        for k in range(n_newFiles):\r\n            for j in range(lines[k]):\r\n                if j == 0:\r\n                    col_type = 'X'\r\n                else:\r\n                    col_type = 'Y'\r\n\r\n                if header[k] is None or len(header[k]) <= j:  # if header is None, use Filename as header\r\n                    shortname = str(FileName[k])\r\n                else:\r\n                    shortname = header[k][j]\r\n                self.data.append(self.create_data(load_data[k][j], shortname=shortname,\r\n                                                  type=col_type, filename=newFiles[k]))\r\n            self.cols = self.cols + lines[k]\r\n\r\n        self.rows = max([len(d[\"data\"]) for d in self.data])\r\n\r\n        self.data_table.setColumnCount(self.cols)\r\n        self.data_table.setRowCount(self.rows)\r\n        self.header_table.setColumnCount(self.cols)\r\n        self.header_table.setRowCount(5)\r\n\r\n        # set header\r\n        headers = ['{} ({})'.format(d[\"shortname\"], d[\"type\"]) for d in self.data]\r\n        self.header_table.setHorizontalHeaderLabels(headers)\r\n        self.create_header_items(cols_before, self.cols)\r\n\r\n        for c in range(cols_before, self.cols):\r\n            for r in range(len(self.data[c][\"data\"])):\r\n                newcell = QTableWidgetItem(str(self.data[c][\"data\"][r]))\r\n                self.data_table.setItem(r, c, newcell)\r\n\r\n        self.pHomeTxt = FileName[0]\r\n\r\n    def update_data(self, item):\r\n        \"\"\" if content of spreadsheet cell is changed, data stored in variable self.data is also changed \"\"\"\r\n        new_cell_content = item.text()\r\n        col = self.data_table.visualColumn(item.column())\r\n        row = item.row()\r\n        if new_cell_content == '':\r\n            self.data_table.takeItem(row, col)\r\n            new_cell_content = np.nan\r\n        try:\r\n            self.data[col][\"data\"][row] = new_cell_content\r\n        except IndexError:  # occurs if index is out of bounds\r\n            self.data[col][\"data\"] = np.append(self.data[col][\"data\"], new_cell_content)\r\n\r\n    def update_header(self, item):\r\n        \"\"\"if header is changed, self.data is changed too\"\"\"\r\n        content = item.text()\r\n        col = item.column()\r\n        row = item.row()\r\n\r\n        if row == 0:    # Long Name\r\n            self.data[col][\"longname\"] = content\r\n        elif row == 1:\r\n            self.data[col][\"axis label\"] = content\r\n        elif row == 2:  # Unit\r\n            self.data[col][\"unit\"] = content\r\n        elif row == 3:  # Comments\r\n            self.data[col][\"comments\"] = content\r\n        elif row == 4:  # F(x) =\r\n            self.data[col][\"formula\"] = content\r\n            if content is None or content == '':\r\n                return\r\n            else:\r\n                Interpreter = FormulaInterpreter(self.data)\r\n                new_data = Interpreter.interprete_formula(content)\r\n                if new_data is not None:\r\n                    self.data[col][\"data\"] = new_data\r\n                    for r in range(len(self.data[col][\"data\"])):\r\n                        newcell = QTableWidgetItem(str(self.data[col][\"data\"][r]))\r\n                        self.data_table.setItem(r, col, newcell)\r\n\r\n    def new_col(self, data_content=None, short_name=None):\r\n        # adds a new column at end of table\r\n        if data_content is None:\r\n            data_content = np.zeros(self.rows)\r\n        elif len(data_content) != self.rows:\r\n            self.mw.show_statusbar_message(\"data has different length than table rows\")\r\n            return\r\n\r\n        if short_name is None:\r\n            short_name = str(chr(ord('A') + self.cols - 1))\r\n        self.cols = self.cols + 1\r\n        self.data_table.setColumnCount(self.cols)\r\n        self.header_table.setColumnCount(self.cols)\r\n        self.data.append(self.create_data(data_content=data_content, shortname=short_name))\r\n        headers = [d[\"shortname\"] + '(' + d[\"type\"] + ')' for d in self.data]\r\n        self.header_table.setHorizontalHeaderLabels(headers)\r\n        for i in range(self.rows):\r\n            cell = QTableWidgetItem(str(data_content[i]))\r\n            self.data_table.setItem(i, self.cols - 1, cell)\r\n\r\n        # Color header cells in yellow\r\n        for r in range(5):\r\n            self.header_table.setItem(r, self.cols - 1, QTableWidgetItem())\r\n            self.header_table.item(r, self.cols - 1).setBackground(QtGui.QColor(255, 255, 200))\r\n\r\n    def get_plot_data(self, plot_all=False):\r\n        \"\"\" get data from selected columns and prepares data for plot \"\"\"\r\n        self.plot_data = []\r\n        plot_content = {\"x\": None,\r\n                        \"y\": None,\r\n                        \"yerr\": None,\r\n                        \"plot type\": None,\r\n                        \"label\": None,\r\n                        \"xaxis\": None,\r\n                        \"yaxis\": None,\r\n                        \"filename\": None,\r\n                        \"spreadsheet title\": None\r\n                        }\r\n\r\n        if plot_all is True:\r\n            selCol = [idx for idx, d in enumerate(self.data) if d[\"type\"] == \"Y\"]\r\n        else:\r\n            # get visual index of selected columns in sorted order\r\n            selCol = sorted(set(self.headers.visualIndex(idx.column()) for idx in self.header_table.selectedIndexes()))\r\n\r\n        # Decides if line or dot plot\r\n        action = self.sender()\r\n        if action.text() == 'Line Plot' or action.text() == 'Plot all':\r\n            plot_type = '-'\r\n        elif action.text() == 'Dot Plot':\r\n            plot_type = 'o'\r\n        else:\r\n            plot_type = None\r\n\r\n        # iterate over all selected columns\r\n        for c in selCol:\r\n            if self.data[c][\"type\"] != 'Y':\r\n                self.mw.show_statusbar_message('Please only select Y-columns!', 4000)\r\n                return\r\n            else:\r\n                k = c - 1\r\n                while k >= 0:\r\n                    if self.data[k][\"type\"] == 'X':\r\n                        # label for plot legende\r\n                        if self.data[c][\"longname\"] is None or self.data[c][\"longname\"] == '':\r\n                            label = self.data[c][\"shortname\"]\r\n                        else:\r\n                            label = self.data[c][\"longname\"]\r\n\r\n                        m = c + 1\r\n                        yerr = None\r\n                        while m <= self.cols:\r\n                            if m == self.cols:\r\n                                yerr = None\r\n                                m = self.cols + 1\r\n                            elif self.data[m][\"type\"] == 'Yerr':\r\n                                yerr = self.data[m][\"data\"]\r\n                                m = self.cols + 1\r\n                            else:\r\n                                m = m + 1\r\n                        self.plot_data.append(plot_content.copy())\r\n                        self.plot_data[-1][\"x\"] = self.data[k][\"data\"]\r\n                        self.plot_data[-1][\"y\"] = self.data[c][\"data\"]\r\n                        self.plot_data[-1][\"filename\"] = self.data[c][\"filename\"]\r\n                        self.plot_data[-1][\"label\"] = label\r\n                        self.plot_data[-1][\"plot type\"] = plot_type\r\n                        self.plot_data[-1][\"yerr\"] = yerr\r\n                        if self.data[k][\"axis label\"] is not None and self.data[k][\"axis label\"] != '':\r\n                            self.plot_data[-1][\"xaxis\"] = self.data[k][\"axis label\"]\r\n                            if self.data[k][\"unit\"] is not None and self.data[k][\"unit\"] != '':\r\n                                self.plot_data[-1][\"xaxis\"] += \" / {}\".format(self.data[k][\"unit\"])\r\n                        if self.data[c][\"axis label\"] is not None and self.data[c][\"axis label\"] != '':\r\n                            self.plot_data[-1][\"yaxis\"] = self.data[c][\"axis label\"]\r\n                            if self.data[c][\"unit\"] is not None and self.data[c][\"unit\"] != \"\":\r\n                                self.plot_data[-1][\"yaxis\"] += \" / {}\".format(self.data[c][\"unit\"])\r\n                        k = -2\r\n                    else:\r\n                        k = k - 1\r\n\r\n                if k == -1:\r\n                    self.mw.show_statusbar_message('At least one dataset Y has no assigned X dataset.', 4000)\r\n                    return\r\n\r\n        # check that x and y have same length to avoid problems later:\r\n        # append Spreadsheet instance\r\n        for pd in self.plot_data:\r\n            # delete all values, which are nan\r\n            if len(pd[\"x\"]) == len(pd[\"y\"]):\r\n                x_bool = np.logical_not(np.isnan(pd[\"x\"]))\r\n                if all(x_bool) is False:\r\n                    pd[\"x\"] = pd[\"x\"][x_bool]\r\n                    pd[\"y\"] = pd[\"y\"][x_bool]\r\n                    # Error\r\n                    if pd[\"yerr\"] is not None:\r\n                        pd[\"yerr\"] = pd[\"yerr\"][x_bool]\r\n\r\n                y_bool = np.logical_not(np.isnan(pd[\"y\"]))\r\n                if all(y_bool) is False:\r\n                    pd[\"x\"] = pd[\"x\"][y_bool]\r\n                    pd[\"y\"] = pd[\"y\"][y_bool]\r\n                    # Error\r\n                    if pd[\"yerr\"] is not None:\r\n                        pd[\"yerr\"] = pd[\"yerr\"][y_bool]\r\n\r\n                pd[\"spreadsheet title\"] = self.windowTitle()\r\n            else:\r\n                self.mw.show_statusbar_message('X and Y have different lengths', 4000)\r\n                return\r\n        # emit signal to MainWindow to create new Plotwindow or add lines to existing plotwindow\r\n        if plot_type is not None:\r\n            self.new_pw_signal.emit()\r\n        else:\r\n            self.add_pw_signal.emit(action.text())\r\n\r\n    def closeEvent(self, event):\r\n        close = QMessageBox()\r\n        close.setWindowTitle('Quit')\r\n        close.setText(\"You sure?\")\r\n        close.setStandardButtons(QMessageBox.Yes | QMessageBox.Cancel)\r\n        close = close.exec_()\r\n\r\n        if close == QMessageBox.Yes:\r\n            self.closeWindowSignal.emit('Spreadsheet', self.windowTitle())\r\n            event.accept()\r\n        else:\r\n            event.ignore()\r\n\r\n\r\n########################################################################################################################\r\n# 4. Plot\r\n########################################################################################################################\r\nclass LineBuilder(matplotlib.lines.Line2D):\r\n    \"\"\"\r\n    Plotting a vertical line in plot, e.g. to define area for fit\r\n    \"\"\"\r\n\r\n    def __init__(self, x, y, canvas, linewidth=1, linestyle=\"-\", color='r', loop=False, parent=None):\r\n        super(LineBuilder, self).__init__(x, y, linewidth=linewidth, linestyle=linestyle, color=color)\r\n        self.canvas = canvas\r\n        self.canvas.figure.gca().add_artist(self)\r\n        self.set_picker(5)\r\n        self.set_pickradius(5)\r\n        self.loop = loop\r\n        self.move_line = False\r\n        self.parent = parent\r\n\r\n        # set event connections\r\n        self.cid_pick = self.canvas.mpl_connect(\"pick_event\", self)\r\n        self.cid_move = self.canvas.mpl_connect(\"motion_notify_event\", self.on_move)\r\n        self.cid_release = self.canvas.mpl_connect(\"button_release_event\", self.on_release)\r\n        self.cid_press = self.canvas.mpl_connect(\"button_press_event\", self)\r\n        self.cid_key = self.canvas.mpl_connect(\"key_press_event\", self.on_key)\r\n        self.canvas.setFocusPolicy(QtCore.Qt.ClickFocus)\r\n        self.canvas.setFocus()\r\n\r\n        self.canvas.draw()\r\n\r\n        if self.loop:\r\n            self.canvas.start_event_loop(10000)\r\n\r\n    def __call__(self, event):\r\n        if event.name == \"pick_event\":\r\n            if event.artist == self:\r\n                self.move_line = True\r\n        elif event.name == \"button_press_event\":\r\n            if event.button == 3:\r\n                self.remove_line()\r\n\r\n    def on_key(self, event):\r\n        if event.key == \"enter\":\r\n            self.remove_line()\r\n\r\n    def on_move(self, event):\r\n        if not self.move_line:\r\n            return\r\n        xs = event.xdata\r\n        if xs is None:\r\n            return\r\n\r\n        self.set_xdata(xs)\r\n        self.canvas.draw()\r\n\r\n    def on_release(self, event):\r\n        self.move_line = False\r\n\r\n    def remove_line(self):\r\n        c = self.canvas\r\n        c.mpl_disconnect(self.cid_pick)\r\n        c.mpl_disconnect(self.cid_move)\r\n        c.mpl_disconnect(self.cid_release)\r\n        c.mpl_disconnect(self.cid_press)\r\n        c.mpl_disconnect(self.cid_key)\r\n\r\n        self.remove()\r\n        c.draw()\r\n\r\n        if self.loop:\r\n            c.stop_event_loop()\r\n\r\n        if self.parent:\r\n            self.parent.remove_vertical_line()\r\n\r\n\r\nclass MoveSpectra:\r\n    def __init__(self, line, scaling=False):\r\n        \"\"\"\r\n        Class to move spectra\r\n        Parameters\r\n        ----------\r\n        line: Line2D\r\n        \"\"\"\r\n\r\n        self.line = line\r\n        self.scaling = scaling\r\n        self.x = line.get_xdata()\r\n        self.y = line.get_ydata()\r\n        self.fig = self.line.figure\r\n        self.canvas = self.fig.canvas\r\n        self.move_line = False  # True if right line is selected, otherwise False\r\n        self.cid1 = self.canvas.mpl_connect('pick_event', self.onpick)\r\n        self.cid2 = self.canvas.mpl_connect('motion_notify_event', self.onmove)\r\n        self.cid3 = self.canvas.mpl_connect('button_release_event', self.onrelease)\r\n        self.canvas.start_event_loop(timeout=10000)\r\n\r\n    def onpick(self, event):\r\n        if event.artist != self.line:\r\n            return\r\n        self.move_line = True\r\n\r\n    def onmove(self, event):\r\n        if not self.move_line:\r\n            return\r\n        # the click locations\r\n        x_click = event.xdata\r\n        y_click = event.ydata\r\n\r\n        if x_click is None or y_click is None:\r\n            return\r\n\r\n        # get index of nearest point\r\n        ind = min(range(len(self.x)), key=lambda i: abs(self.x[i] - x_click))\r\n\r\n        if not self.scaling:\r\n            shift_factor = y_click - self.y[ind]\r\n            self.y = self.y + shift_factor\r\n        else:\r\n            scale_factor = y_click / self.y[ind]\r\n            self.y = self.y * scale_factor\r\n\r\n        self.line.set_ydata(self.y)\r\n        self.canvas.draw()\r\n\r\n    def onrelease(self, event):\r\n        if self.move_line:\r\n            self.canvas.mpl_disconnect(self.cid1)\r\n            self.canvas.mpl_disconnect(self.cid2)\r\n            self.canvas.mpl_disconnect(self.cid3)\r\n            self.move_line = False\r\n            self.canvas.stop_event_loop(self)\r\n\r\n\r\nclass LineDrawer:\r\n    def __init__(self, arrow):\r\n        \"\"\"\r\n        Class to draw lines and arrows\r\n        idea: https://github.com/yuma-m/matplotlib-draggable-plot\r\n\r\n        Parameters\r\n        ----------\r\n        arrow: FancyArrowPatch\r\n        \"\"\"\r\n        self.arrow = arrow\r\n        self.fig = self.arrow.figure\r\n        self.ax = self.fig.axes[0]\r\n        self.c = self.fig.canvas\r\n        posA, *_, posB = self.arrow.get_path()._vertices\r\n        self.posA = list(posA)\r\n        self.posB = list(posB)\r\n\r\n        # get arrow style, head length, head width\r\n        arrowstyle = self.arrow.get_arrowstyle()  # get arrow_style of arrow, returns object\r\n        self.head_length = arrowstyle.head_length\r\n        self.head_width = arrowstyle.head_width\r\n        arrowstyle_start = str(arrowstyle).split(' ', 1)[0]  # get object name without address x0....\r\n        list_of_styles = mpatches.ArrowStyle.get_styles()  # get all possible arrow styles, returns dictionary\r\n        self.arrow_style = \"-\"\r\n        for key, val in list_of_styles.items():  # compare arrow style with arrowstyle list to\r\n            if str(mpatches.ArrowStyle(key)).split(' ', 1)[0] == arrowstyle_start:\r\n                # in order to get arrow style name (e.g. '->')\r\n                self.arrow_style = key\r\n\r\n        # get color\r\n        self.color = mcolors.to_hex(mcolors.to_rgba(self.arrow.get_edgecolor(), self.arrow.get_alpha()), keep_alpha=True)\r\n\r\n        # get line width\r\n        self.line_width = self.arrow.get_linewidth()\r\n\r\n        # get line style\r\n        self.line_style = self.arrow.get_linestyle()\r\n\r\n        self.pickedPoint = None\r\n        self.arrow.set_picker(5)\r\n\r\n        self.c.mpl_connect('pick_event', self.pickpoint)\r\n        self.c.mpl_connect('motion_notify_event', self.movepoint)\r\n        self.c.mpl_connect('button_release_event', self.unpickpoint)\r\n\r\n    def pickpoint(self, event):\r\n        if event.artist == self.arrow and event.mouseevent.button == 1:\r\n            min_distance = 25\r\n            distance_to_A = math.hypot(event.mouseevent.xdata - self.posA[0], event.mouseevent.ydata - self.posA[1])\r\n            distance_to_B = math.hypot(event.mouseevent.xdata - self.posB[0], event.mouseevent.ydata - self.posB[1])\r\n            if distance_to_A < min_distance:\r\n                self.pickedPoint = self.posA\r\n            elif distance_to_B < min_distance:\r\n                self.pickedPoint = self.posB\r\n            else:\r\n                self.pickedPoint = None\r\n                return\r\n            self.selectedPoint, = self.ax.plot(self.pickedPoint[0], self.pickedPoint[1], 'o', ms=12, alpha=0.4,\r\n                                               color='yellow')\r\n            self.c.draw()\r\n        elif event.artist == self.arrow and event.mouseevent.button == 3:\r\n            self.options()\r\n        else:\r\n            pass\r\n\r\n    def movepoint(self, event):\r\n        if not self.pickedPoint:\r\n            return\r\n        elif event.xdata is None or event.ydata is None:\r\n            return\r\n        else:\r\n            if self.pickedPoint == self.posA:\r\n                self.posA = [event.xdata, event.ydata]\r\n            elif self.pickedPoint == self.posB:\r\n                self.posB = [event.xdata, event.ydata]\r\n            else:\r\n                return\r\n            self.pickedPoint = [event.xdata, event.ydata]\r\n            self.arrow.set_positions(self.posA, self.posB)\r\n            self.selectedPoint.set_data(self.pickedPoint)\r\n            self.c.draw()\r\n\r\n    def unpickpoint(self, event):\r\n        if self.pickedPoint and event.button == 1:\r\n            self.pickedPoint = None\r\n            self.selectedPoint.remove()\r\n            self.c.draw()\r\n        else:\r\n            return\r\n\r\n    def options(self):\r\n        \"\"\"Options dialog\"\"\"\r\n        lineOptions = [\r\n            ('Width', self.line_width),\r\n            ('Line style', [self.line_style,\r\n                            ('-', 'solid'),\r\n                            ('--', 'dashed'),\r\n                            ('-.', 'dashDot'),\r\n                            (':', 'dotted'),\r\n                            ('None', 'None')]),\r\n            ('Color', self.color),\r\n            ('Remove Line', False)\r\n        ]\r\n\r\n        arrowOptions = [\r\n            ('Arrow Style', [self.arrow_style, '-', '<-', '->', '<->', '-|>', '<|-|>']),\r\n            ('Head Length', self.head_length),\r\n            ('Head Wdith', self.head_width),\r\n        ]\r\n\r\n        positionOptions = [\r\n            ('x Start', self.posA[0]),\r\n            ('y Start', self.posA[1]),\r\n            ('x End', self.posB[0]),\r\n            ('y End', self.posB[1]),\r\n        ]\r\n\r\n        optionsList = [(lineOptions, \"Line\", \"\"), (arrowOptions, \"Arrow\", \"\"), (positionOptions, 'Postion', '')]\r\n\r\n        selectedOptions = formlayout.fedit(optionsList, title=\"Line options\", apply=self.apply_options)\r\n        if selectedOptions is not None:\r\n            self.apply_options(selectedOptions)\r\n\r\n    def apply_options(self, selectedOptions):\r\n        lineOptions = selectedOptions[0]\r\n        arrowOptions = selectedOptions[1]\r\n        positionOptions = selectedOptions[2]\r\n\r\n        (self.line_width, self.line_style, self.color, remove_line) = lineOptions\r\n        (self.arrow_style, self.head_length, self.head_width) = arrowOptions\r\n        (xStart, yStart, xEnd, yEnd) = positionOptions\r\n\r\n        self.arrow.set_linewidth(self.line_width)\r\n        self.arrow.set_linestyle(self.line_style)\r\n        self.arrow.set_color(self.color)\r\n        if self.arrow_style != '-':\r\n            self.arrow.set_arrowstyle(self.arrow_style, head_length=self.head_length, head_width=self.head_width)\r\n        else:\r\n            self.arrow.set_arrowstyle(self.arrow_style)\r\n\r\n        self.posA[0] = xStart\r\n        self.posA[1] = yStart\r\n        self.posB[0] = xEnd\r\n        self.posB[1] = yEnd\r\n        self.arrow.set_positions(self.posA, self.posB)\r\n\r\n        if remove_line is True:\r\n            self.arrow.remove()\r\n\r\n        self.c.draw()\r\n\r\n\r\nclass InsertText:\r\n    def __init__(self, text_annotation, main_window):\r\n        self.text_annotation = text_annotation\r\n        self.mw = main_window\r\n        self.fig = self.text_annotation.figure\r\n        if self.fig is None or self.text_annotation is None:\r\n            return\r\n        self.fig.canvas.mpl_connect('pick_event', self.on_pick)\r\n\r\n        # get text\r\n        self.text = self.text_annotation.get_text()\r\n        # get position in plot coordinates\r\n        self.position = self.text_annotation.xyann\r\n        # get font size\r\n        self.font_size = self.text_annotation.get_fontsize()\r\n        # get color of text\r\n        self.color = mcolors.to_hex(mcolors.to_rgba(self.text_annotation.get_color(),\r\n                                                    self.text_annotation.get_alpha()), keep_alpha=True)\r\n\r\n    def on_pick(self, event):\r\n        if event.artist == self.text_annotation and event.mouseevent.button == 1 and event.mouseevent.dblclick is True:\r\n            self.edit()\r\n        elif event.artist == self.text_annotation and event.mouseevent.button == 1:\r\n            self.cid2 = self.fig.canvas.mpl_connect('button_release_event', self.on_release)\r\n            self.cid3 = self.fig.canvas.mpl_connect('motion_notify_event', self.on_motion)\r\n        elif event.artist == self.text_annotation and event.mouseevent.button == 3:\r\n            self.text_options()\r\n        else:\r\n            pass\r\n\r\n    def edit(self):\r\n        self.textbox = QtWidgets.QLineEdit()\r\n        self.textbox.setWindowFlags(Qt.FramelessWindowHint)  # Hide title bar\r\n        self.textbox.setHidden(False)  # Make it visible\r\n        self.textbox.setText(self.text_annotation.get_text())\r\n        bb = self.text_annotation.get_window_extent()\r\n        # width, height = int(bb.width), int(bb.height)\r\n        x, y = bb.get_points()[0]\r\n        mw_height = self.mw.geometry().height()\r\n        global_point = self.fig.canvas.mapFromGlobal(self.fig.canvas.pos())\r\n        x_canvas, y_canvas = int(global_point.x()), int(global_point.y())\r\n        self.textbox.move(int(x - x_canvas), int(mw_height - y + y_canvas / 2))\r\n        self.textbox.returnPressed.connect(self.finish_edit)\r\n        self.textbox.setFocus()\r\n\r\n    def finish_edit(self):\r\n        self.text = self.textbox.text()\r\n        self.text_annotation.set_text(self.text)\r\n        self.textbox.setHidden(True)\r\n        self.fig.canvas.draw()\r\n\r\n    def on_motion(self, event):\r\n        self.position = (event.xdata, event.ydata)\r\n        self.text_annotation.set_position(self.position)\r\n        self.fig.canvas.draw()\r\n\r\n    def on_release(self, event):\r\n        self.fig.canvas.mpl_disconnect(self.cid2)\r\n        self.fig.canvas.mpl_disconnect(self.cid3)\r\n\r\n    def text_options(self):\r\n        \"\"\"Option dialog\"\"\"\r\n        text_options_list = [\r\n            ('Text', self.text),\r\n            ('Font size', self.font_size),\r\n            ('Color', self.color),\r\n            ('Remove Text', False)\r\n        ]\r\n\r\n        text_option_menu = formlayout.fedit(text_options_list, title=\"Text options\")\r\n        if text_option_menu is not None:\r\n            self.apply_callback(text_option_menu)\r\n\r\n    def apply_callback(self, options):\r\n        (self.text, self.font_size, self.color, remove_text) = options\r\n\r\n        self.text_annotation.set_text(self.text)\r\n        self.text_annotation.set_fontsize(self.font_size)\r\n        self.text_annotation.set_color(self.color)\r\n        if remove_text is True:\r\n            self.text_annotation.remove()\r\n        self.fig.canvas.draw()\r\n\r\n\r\nclass DataPointPicker:\r\n    \"\"\"\r\n    Class to select a datapoint within the spectrum\r\n    \"\"\"\r\n\r\n    def __init__(self, line, a):\r\n        \"\"\"\r\n        Creates a yellow dot around a selected data point\r\n        \"\"\"\r\n        self.xs = line.get_xdata()\r\n        self.ys = line.get_ydata()\r\n        self.line = line\r\n        self.fig = self.line.figure\r\n        self.idx = a\r\n        self.selected, = self.fig.axes[0].plot(self.xs[a], self.ys[a], 'o',\r\n                                               ms=12, alpha=0.4,\r\n                                               color='yellow')  # Yellow point to mark selected Data points\r\n        self.fig.canvas.draw()\r\n        self.fig.canvas.setFocusPolicy(QtCore.Qt.ClickFocus)\r\n        self.fig.canvas.setFocus()\r\n\r\n        self.cid1 = self.fig.canvas.mpl_connect('pick_event', self.onpick)\r\n        self.cid2 = self.fig.canvas.mpl_connect('key_press_event', self.onpress)\r\n\r\n        self.fig.canvas.start_event_loop(timeout=10000)\r\n\r\n    def onpick(self, event):\r\n        N = len(event.ind)\r\n        if not N:\r\n            return True\r\n\r\n        # the click locations\r\n        x = event.mouseevent.xdata\r\n        y = event.mouseevent.ydata\r\n        distances = np.hypot(x - self.xs[event.ind], y - self.ys[event.ind])\r\n        indmin = distances.argmin()\r\n        self.idx = int(event.ind[indmin])\r\n\r\n        self.selected.set_data(self.xs[self.idx], self.ys[self.idx])\r\n        self.selected.set_visible(True)\r\n        self.fig.canvas.draw()\r\n\r\n    def onpress(self, event):\r\n        if event.key == 'enter':\r\n            self.fig.canvas.mpl_disconnect(self.cid1)\r\n            self.fig.canvas.mpl_disconnect(self.cid2)\r\n            self.fig.canvas.stop_event_loop(self)\r\n            self.selected.remove()\r\n            self.fig.canvas.draw()\r\n            return\r\n        elif event.key == 'right':\r\n            inc = 1\r\n        elif event.key == 'left':\r\n            inc = -1\r\n        else:\r\n            return\r\n        self.idx += inc\r\n        self.selected.set_data(self.xs[self.idx], self.ys[self.idx])\r\n        self.fig.canvas.draw()\r\n\r\n\r\nclass DataSetSelecter(QtWidgets.QDialog):\r\n    \"\"\"\r\n    Select one or several datasets\r\n\r\n    Parameters\r\n    ----------\r\n    data_set_names           # names of all datasets\r\n    select_only_one          # if True only on Dataset can be selected\r\n    \"\"\"\r\n\r\n    def __init__(self, data_set_names, select_only_one=True):\r\n        super(DataSetSelecter, self).__init__(parent=None)\r\n        self.data_set_names = data_set_names\r\n        self.select_only_one = select_only_one\r\n        self.selectedDatasetNumber = []\r\n        self.CheckDataset = []\r\n        self.create_dialog()\r\n\r\n    def create_dialog(self):\r\n        layout = QtWidgets.QGridLayout()\r\n        if self.select_only_one is False:\r\n            check_all = QCheckBox(\"Select all\", self)\r\n            myFont = QtGui.QFont()\r\n            myFont.setBold(True)\r\n            check_all.setFont(myFont)\r\n            check_all.stateChanged.connect(self.select_all)\r\n            layout.addWidget(check_all, 0, 0)\r\n\r\n        for idx, name in enumerate(self.data_set_names):\r\n            self.CheckDataset.append(QCheckBox(name, self))\r\n            layout.addWidget(self.CheckDataset[idx], idx + 1, 0)\r\n            if self.select_only_one is True:\r\n                self.CheckDataset[idx].stateChanged.connect(self.onStateChange)\r\n\r\n        ok_button = QPushButton(\"OK\", self)\r\n        layout.addWidget(ok_button, len(self.data_set_names) + 1, 0)\r\n        ok_button.clicked.connect(self.Ok_button)\r\n        self.setLayout(layout)\r\n        self.setWindowTitle(\"Select Dataset\")\r\n        self.exec_()\r\n\r\n    @pyqtSlot(int)\r\n    def onStateChange(self, state):\r\n        if state == Qt.Checked:\r\n            for j in self.CheckDataset:\r\n                if self.sender() != j:\r\n                    j.setChecked(False)\r\n\r\n    @pyqtSlot(int)\r\n    def select_all(self, state):\r\n        if state == Qt.Checked:\r\n            for cd in self.CheckDataset:\r\n                cd.setCheckState(Qt.Checked)\r\n        elif state == Qt.Unchecked:\r\n            for cd in self.CheckDataset:\r\n                cd.setCheckState(Qt.Unchecked)\r\n\r\n    def Ok_button(self):\r\n        \"\"\" OK Button for function SecetedDataset \"\"\"\r\n        for idx, d in enumerate(self.CheckDataset):\r\n            if d.isChecked():\r\n                self.selectedDatasetNumber.append(idx)\r\n            else:\r\n                pass\r\n        self.close()\r\n\r\n\r\nclass BaselineCorrectionMethods:\r\n    \"\"\"Class containing all implemented methods of base line correction\"\"\"\r\n    def __init__(self):\r\n        # all implemented baseline correction methods\r\n        self.method_groups = {\r\n            \"Whittaker\":\r\n                [\r\n                    \"Asymmetric Least Square\",\r\n                    \"Improved Asymmetric Least Square\",\r\n                    \"Adaptive Iteratively Reweighted Penalized Least Squares\",\r\n                    \"Asymmetrically Reweighted Penalized Least Squares\",\r\n                    \"Doubly Reweighted Penalized Least Squares\",\r\n                    \"Derivative Peak-Screening Asymmetric Least Square\"\r\n                ],\r\n            \"Spline\":\r\n                [\"Univariate Spline\", \"GCV Spline\"],\r\n            \"Polynomial\":\r\n                [\"Polynomial\", \"Polynomial (without regions)\"],\r\n            \"Miscellaneous\":\r\n                [\"Rubberband\", \"Rolling Ball\"]\r\n        }\r\n        self.methods = {\r\n            \"Rubberband\":\r\n                {\"function\": self.rubberband, \"parameter\": {}},\r\n            \"Rolling Ball\":\r\n                {\"function\": self.rolling_ball, \"parameter\": {\"half window\": 5}},\r\n            \"Polynomial\":\r\n                {\"function\": self.polynomial, \"parameter\": {\"order\": 3, \"roi\": [[150, 160], [3800, 4000]]}},\r\n            \"Polynomial (without regions)\":\r\n                {\"function\": self.polynomial_02, \"parameter\": {\"order\": 3}},\r\n            \"Univariate Spline\":\r\n                {\"function\": self.unispline, \"parameter\": {\"s\": 1e0, \"roi\": [[150, 160], [3800, 4000]]}},\r\n            \"GCV Spline\":\r\n                {\"function\": self.gcvspline, \"parameter\": {\"s\": 0.1, \"roi\": [[150, 160], [3800, 4000]]}},\r\n            \"Asymmetric Least Square\":\r\n                {\"function\": self.ALS, \"parameter\": {\"p\": 0.001, \"lambda\": 10000000}},\r\n            \"Improved Asymmetric Least Square\":\r\n                {\"function\": self.imALS, \"parameter\": {\"p\": 0.001, \"lambda\": 100000}},\r\n            \"Adaptive Iteratively Reweighted Penalized Least Squares\":\r\n                {\"function\": self.airPLS, \"parameter\": {\"lambda\": 10000000}},\r\n            \"Asymmetrically Reweighted Penalized Least Squares\":\r\n                {\"function\": self.arPLS, \"parameter\": {\"lambda\": 10000000}},\r\n            \"Doubly Reweighted Penalized Least Squares\":\r\n                {\"function\": self.drPLS, \"parameter\": {\"lambda\": 1000000, \"eta\": 0.5}},\r\n            \"Derivative Peak-Screening Asymmetric Least Square\":\r\n                {\"function\": self.derpsALS, \"parameter\": {\"lambda\": 1000000, \"p\": 0.01}}\r\n        }\r\n\r\n        # contains current method, for baseline dialog; start method is ASL\r\n        self.current_method = \"Asymmetric Least Square\"\r\n        self.current_group = \"Whittaker\"\r\n\r\n    def rubberband(self, x, y):\r\n        \"\"\"\r\n        Rubberband Baseline Correction\r\n        source: https://dsp.stackexchange.com/questions/2725/how-to-perform-a-rubberband-correction-on-spectroscopic-data\r\n        \"\"\"\r\n        # Find the convex hull\r\n        v = scipy.spatial.ConvexHull(np.array(list(zip(x, y)))).vertices\r\n        # Rotate convex hull vertices until they start from the lowest one\r\n        v = np.roll(v, -v.argmin())\r\n        # Leave only the ascending part\r\n        v = v[:v.argmax()]\r\n\r\n        # Create baseline using linear interpolation between vertices\r\n        z = np.interp(x, x[v], y[v])\r\n        y = y - z\r\n        # y - background-corrected Intensity-values, z - background\r\n        return y, z\r\n\r\n    def rolling_ball(self, x, y, half_window):\r\n        baseline, _ = pybaselines.morphological.rolling_ball(y, half_window=int(half_window))\r\n        y_corr = y - baseline\r\n        return y_corr, baseline\r\n\r\n    def polynomial(self, x, y, p_order, roi):\r\n        y, z = rp.baseline(x, y, np.array(roi), \"poly\", polynomial_order=p_order)\r\n        y = y.flatten()\r\n        z = z.flatten()\r\n        return y, z\r\n\r\n    def polynomial_02(self, x, y, p_order):\r\n        baseline, _ = pybaselines.polynomial.poly(y, x_data=x, poly_order=int(p_order))\r\n        y_corr = y - baseline\r\n        return y_corr, baseline\r\n\r\n    def unispline(self, x, y, s, roi):\r\n        \"\"\"\r\n        @param x: x data\r\n        @param y: y data\r\n        @param s: Positive smoothing factor used to choose the number of knots.\r\n        Number of knots will be increased until the smoothing condition is satisfied:\r\n        @param roi: region of interest\r\n        @return: baseline corrected y data and baseline z\r\n        \"\"\"\r\n        try:\r\n            y, z = rp.baseline(x, y, np.array(roi), \"unispline\", s=s)\r\n        except ValueError as e:\r\n            print(e)\r\n            return None\r\n        y = y.flatten()\r\n        z = z.flatten()\r\n        return y, z\r\n\r\n    def gcvspline(self, x, y, s, roi):\r\n        \"\"\"\r\n        @param x: x data\r\n        @param y: y data\r\n        @param s: Positive smoothing factor used to choose the number of knots.\r\n        Number of knots will be increased until the smoothing condition is satisfied:\r\n        @param roi: region of interest\r\n        @return: baseline corrected y data and baseline z\r\n        \"\"\"\r\n        try:\r\n            y, z = rp.baseline(x, y, np.array(roi), 'gcvspline', s=s)\r\n        except UnboundLocalError:\r\n            print('ERROR: Install gcvspline to use this mode (needs a working FORTRAN compiler).')\r\n            return None\r\n        y = y.flatten()\r\n        z = z.flatten()\r\n        return y, z\r\n\r\n    def ALS(self, x, y, p, lam):\r\n        \"\"\"\r\n        baseline correction with Asymmetric Least Squares smoothing\r\n        based on: P. H. C. Eilers and H. F. M. Boelens. Baseline correction with asymmetric least squares smoothing.\r\n        Leiden University Medical Centre Report , 1(1):5, 2005. from Eilers and Boelens\r\n        also look at: https://stackoverflow.com/questions/29156532/python-baseline-correction-library\r\n        \"\"\"\r\n        baseline, _ = whittaker.asls(y, lam=lam, p=p)\r\n        y_corr = y - baseline\r\n        return y_corr, baseline\r\n\r\n    def airPLS(self, x, y, lam):\r\n        \"\"\"\r\n        adaptive  iteratively  reweighted  penalized  least  squares\r\n        based on: Zhi-Min  Zhang,  Shan  Chen,  and  Yi-Zeng Liang.\r\n        Baseline correction using adaptive iteratively reweighted penalized least squares.\r\n        Analyst, 135(5):11381146, 2010.\r\n        \"\"\"\r\n        baseline, params = whittaker.airpls(y, lam=lam)\r\n        y_corr = y - baseline\r\n        return y_corr, baseline\r\n\r\n    def arPLS(self, x, y, lam):\r\n        \"\"\"\r\n        (automatic) Baseline correction using asymmetrically reweighted penalized least squares smoothing.\r\n        Baek et al. 2015, Analyst 140: 250-257;\r\n        \"\"\"\r\n        baseline, params = whittaker.arpls(y, lam=lam)\r\n        y_corr = y - baseline\r\n        return y_corr, baseline\r\n\r\n    def drPLS(self, x, y, lam, eta):\r\n        \"\"\"(automatic) Baseline correction method based on doubly reweighted penalized least squares.\r\n        Xu et al., Applied Optics 58(14):3913-3920.\"\"\"\r\n        baseline, params = whittaker.drpls(y, lam=lam, eta=eta)\r\n        y_corr = y - baseline\r\n        return y_corr, baseline\r\n\r\n    def imALS(self, x, y, p, lam):\r\n        \"\"\"\r\n        He, Shixuan, et al. \"Baseline correction for Raman spectra using an improved asymmetric least squares method.\"\r\n        Analytical Methods 6.12 (2014): 4402-4407.\r\n        \"\"\"\r\n        baseline, params = whittaker.iasls(y, lam=lam, p=p)\r\n        y_corr = y - baseline\r\n        return y_corr, baseline\r\n\r\n    def derpsALS(self, x, y, lam, p, k=None):\r\n        \"\"\"\r\n        Korepanov, Vitaly I. \"Asymmetric leastsquares baseline algorithm with peak screening for automatic processing\r\n        of the Raman spectra.\" Journal of Raman Spectroscopy 51.10 (2020): 2061-2065.\r\n        @param x:\r\n        @param y:\r\n        @param lam:\r\n        @param p:\r\n        @param k:\r\n        @return:\r\n        \"\"\"\r\n        baseline, params = whittaker.derpsalsa(y, lam=lam, p=p, k=k)\r\n        y_corr = y - baseline\r\n        return y_corr, baseline\r\n\r\n\r\nclass BaselineCorrectionsDialog(QMainWindow):\r\n    def __init__(self, parent, blc_methods):\r\n        super(BaselineCorrectionsDialog, self).__init__(parent=parent)\r\n        # contains parent: class PlotWindow\r\n        self.pw = parent\r\n\r\n        # get axis and figure of PlotWindow\r\n        self.ax = self.pw.ax\r\n        self.fig = self.pw.fig\r\n\r\n        self.blcm = blc_methods\r\n        self.methods = self.blcm.methods\r\n        self.method_groups = self.blcm.method_groups\r\n\r\n        self.spectrum = None\r\n        self.x = None\r\n        self.y = None\r\n        # list containing vertical spans (matplotlib.patches.Polygon) to color regions of interests\r\n        self.roi_spans = []\r\n\r\n        self.parameter_editor = {}\r\n        self.parameter_label = {}\r\n\r\n    def get_baseline(self, x, y, spectrum):\r\n        self.x = x\r\n        self.y = y\r\n        self.spectrum = spectrum\r\n\r\n        self.plot_baseline()\r\n        self.create_dialog()\r\n        self.apply_call()\r\n\r\n    def create_dialog(self):\r\n        # layouts\r\n        main_layout = QtWidgets.QVBoxLayout()\r\n        mthd_prmtr_layout = QtWidgets.QHBoxLayout()\r\n        self.parameter_layout = QtWidgets.QGridLayout()\r\n\r\n        method_box = self.create_method_box()\r\n        self.fill_parameter_layout()\r\n        parameter_box = QtWidgets.QGroupBox(\"Parameter\")\r\n        button_layout = self.create_buttons()\r\n\r\n        # set layouts\r\n        parameter_box.setLayout(self.parameter_layout)\r\n        mthd_prmtr_layout.addWidget(method_box)\r\n        mthd_prmtr_layout.addWidget(parameter_box)\r\n        main_layout.addLayout(mthd_prmtr_layout)\r\n        main_layout.addLayout(button_layout)\r\n        widget = QtWidgets.QWidget()\r\n        widget.setLayout(main_layout)\r\n        self.setCentralWidget(widget)\r\n        self.setWindowTitle(\"Baseline\")\r\n        self.setWindowModality(Qt.ApplicationModal)\r\n        self.show()\r\n\r\n    def create_method_box(self):\r\n        method_layout = QtWidgets.QVBoxLayout()\r\n        method_box = QtWidgets.QGroupBox(\"Methods\")\r\n\r\n        # combo box for method category\r\n        method_combo_widget = QtWidgets.QComboBox()\r\n        for key in self.method_groups.keys():\r\n            method_combo_widget.addItem(key)\r\n        method_combo_widget.currentTextChanged.connect(self.method_group_changed)\r\n        method_layout.addWidget(method_combo_widget)\r\n\r\n        # combo box for method\r\n        self.combo_widget_methods = QtWidgets.QComboBox()\r\n        for me in self.method_groups[self.blcm.current_group]:\r\n            self.combo_widget_methods.addItem(me)\r\n        self.combo_widget_methods.currentTextChanged.connect(self.method_change)\r\n        method_layout.addWidget(self.combo_widget_methods)\r\n\r\n        method_box.setLayout(method_layout)\r\n\r\n        return method_box\r\n\r\n    def method_group_changed(self, text):\r\n        self.blcm.current_group = text\r\n        self.combo_widget_methods.clear()\r\n        for me in self.method_groups[self.blcm.current_group]:\r\n            self.combo_widget_methods.addItem(me)\r\n        self.method_change(self.method_groups[self.blcm.current_group][0])\r\n\r\n    def method_change(self, text):\r\n        if text is not None and text != \"\":\r\n            self.blcm.current_method = text\r\n        elif text == \"\":\r\n            return\r\n\r\n        # clear layout\r\n        self.clear_layout(self.parameter_layout)\r\n\r\n        self.parameter_editor = {}\r\n        self.parameter_label = {}\r\n\r\n        # create new layout\r\n        self.fill_parameter_layout()\r\n        self.update()\r\n\r\n    def fill_parameter_layout(self):\r\n        idx = 0\r\n        for key, val in self.methods[self.blcm.current_method][\"parameter\"].items():\r\n            if key == \"roi\":\r\n                self.add_roi_editors(val, idx)\r\n                continue\r\n            self.parameter_label[key] = QtWidgets.QLabel(key)\r\n            self.parameter_editor[key] = QtWidgets.QLineEdit()\r\n            self.parameter_layout.addWidget(self.parameter_editor[key], idx, 0)\r\n            self.parameter_layout.addWidget(self.parameter_label[key], idx, 1)\r\n            self.parameter_editor[key].setText(str(val))\r\n            self.methods[self.blcm.current_method][\"parameter\"][key] = float(self.parameter_editor[key].text())\r\n            idx += 1\r\n\r\n    def add_roi_editors(self, roi, idx):\r\n        roi_editors = []\r\n        roi_layout_v = QtWidgets.QVBoxLayout()\r\n        button_layout_v = QtWidgets.QVBoxLayout()\r\n        button_layout_h = QtWidgets.QHBoxLayout()\r\n        self.parameter_label[\"roi\"] = QtWidgets.QLabel(\"regions of interest\")\r\n        button_add = QtWidgets.QPushButton(\"+\")\r\n        button_remove = QtWidgets.QPushButton(\"-\")\r\n        button_layout_h.addWidget(button_add)\r\n        button_layout_h.addWidget(button_remove)\r\n        button_layout_v.addWidget(self.parameter_label[\"roi\"])\r\n        button_layout_v.addLayout(button_layout_h)\r\n        button_add.clicked.connect(self.add_roi)\r\n        button_remove.clicked.connect(self.del_roi)\r\n        self.parameter_layout.addLayout(button_layout_v, idx, 1)\r\n        for i, r in enumerate(roi):\r\n            roi_layout_h = QtWidgets.QHBoxLayout()\r\n            editor1 = QtWidgets.QLineEdit()\r\n            editor1.setText(str(r[0]))\r\n            roi_layout_h.addWidget(editor1)\r\n            editor2 = QtWidgets.QLineEdit()\r\n            editor2.setText(str(r[1]))\r\n            roi_layout_h.addWidget(editor2)\r\n            roi_layout_v.addLayout(roi_layout_h)\r\n            roi_editors.append([editor1, editor2])\r\n            self.methods[self.blcm.current_method][\"parameter\"][\"roi\"][i] = [float(editor1.text()),\r\n                                                                             float(editor2.text())]\r\n        self.parameter_layout.addLayout(roi_layout_v, idx, 0)\r\n        self.parameter_editor[\"roi\"] = roi_editors\r\n\r\n    def add_roi(self):\r\n        try:\r\n            last_roi = self.methods[self.blcm.current_method][\"parameter\"][\"roi\"][-1][1]\r\n        except IndexError:\r\n            last_roi = 140\r\n        self.methods[self.blcm.current_method][\"parameter\"][\"roi\"].append([last_roi+10, last_roi+40])\r\n        self.method_change(None)\r\n\r\n    def del_roi(self):\r\n        try:\r\n            del self.methods[self.blcm.current_method][\"parameter\"][\"roi\"][-1]\r\n        except IndexError:\r\n            pass\r\n        self.method_change(None)\r\n\r\n    def sort_roi(self, roi_list):\r\n        return sorted(roi_list, key=lambda x: x[0])\r\n\r\n    def create_buttons(self):\r\n        # buttons for ok, close and apply\r\n        button_layout = QtWidgets.QHBoxLayout()\r\n\r\n        self.finishbutton = QPushButton('Ok')\r\n        self.finishbutton.setCheckable(True)\r\n        self.finishbutton.setToolTip('Are you happy with the start parameters? '\r\n                                     '\\n Close the dialog window and save the baseline!')\r\n        self.finishbutton.clicked.connect(self.finish_call)\r\n        button_layout.addWidget(self.finishbutton)\r\n\r\n        self.closebutton = QPushButton('Close')\r\n        self.closebutton.setCheckable(True)\r\n        self.closebutton.setToolTip('Closes the dialog window and baseline is not saved.')\r\n        self.closebutton.clicked.connect(self.close)\r\n        button_layout.addWidget(self.closebutton)\r\n\r\n        applybutton = QPushButton('Apply')\r\n        applybutton.setToolTip('Do you want to try the fit parameters? \\n Lets do it!')\r\n        applybutton.clicked.connect(self.apply_call)\r\n        button_layout.addWidget(applybutton)\r\n\r\n        return button_layout\r\n\r\n    def plot_baseline(self):\r\n        params = self.methods[self.blcm.current_method][\"parameter\"].values()\r\n        return_value = self.methods[self.blcm.current_method][\"function\"](self.x, self.y, *params)\r\n        if return_value is None:\r\n            return\r\n        else:\r\n            yb, zb = return_value\r\n        self.base_line, = self.ax.plot(self.x, zb, \"c--\", label=\"baseline ({})\".format(self.spectrum.get_label()))\r\n        self.blcSpektrum, = self.ax.plot(self.x, yb, \"c-\",\r\n                                         label=\"baseline-corrected ({})\".format(self.spectrum.get_label()))\r\n        self.fig.canvas.draw()\r\n\r\n    def clear_layout(self, layout):\r\n        for i in reversed(range(layout.count())):\r\n            widget = layout.itemAt(i).widget()\r\n            if widget is None:\r\n                self.clear_layout(layout.itemAt(i))\r\n            else:\r\n                widget.setParent(None)\r\n\r\n    def clear_plot(self):\r\n        try:\r\n            self.blcSpektrum.remove()\r\n        except ValueError:\r\n            return\r\n        self.base_line.remove()\r\n        for rs in self.roi_spans:\r\n            rs.remove()\r\n        self.roi_spans = []\r\n        self.fig.canvas.draw()\r\n\r\n    def finish_call(self):\r\n        params = self.methods[self.blcm.current_method][\"parameter\"].values()\r\n        name = self.spectrum.get_label()\r\n        for key, val in self.parameter_editor.items():\r\n            if key == \"roi\":\r\n                for i, roi_pe in enumerate(val):\r\n                    roi_start = float(roi_pe[0].text())\r\n                    roi_end = float(roi_pe[1].text())\r\n                    self.methods[self.blcm.current_method][\"parameter\"][\"roi\"][i] = [roi_start, roi_end]\r\n                self.methods[self.blcm.current_method][\"parameter\"][\"roi\"] = self.sort_roi(\r\n                    self.methods[self.blcm.current_method][\"parameter\"][\"roi\"])\r\n                continue\r\n            self.methods[self.blcm.current_method][\"parameter\"][key] = float(val.text())\r\n        return_value = self.methods[self.blcm.current_method][\"function\"](self.x, self.y, *params)\r\n        if return_value is None:\r\n            self.close()\r\n            return\r\n        else:\r\n            yb, zb = return_value\r\n\r\n        # Plot\r\n        label_spct = \"{} (baseline-corrected)\".format(name)\r\n        spct_corr, = self.ax.plot(self.x, yb, \"c-\", label=label_spct)\r\n        self.pw.data.append(self.pw.create_data(self.x, yb, line=spct_corr, label=label_spct, style=\"-\"))\r\n        baseline, = self.ax.plot(self.x, zb, \"c--\", label=\"baseline ({})\".format(name))\r\n        self.pw.data.append(self.pw.create_data(\r\n            self.x, zb, line=baseline, label=\"baseline ({})\".format(name), style=\"-\"))\r\n        self.fig.canvas.draw()\r\n        self.close()\r\n\r\n        # Save baseline corrected data\r\n        # (fileBaseName, fileExtension) = os.path.splitext(name)\r\n        # startFileDirName = os.path.dirname(self.pw.selectedData[0][\"filename\"])\r\n        # startFileBaseName = startFileDirName + \"/\" + fileBaseName\r\n        # startFileName = startFileBaseName + \"_bgc.txt\"\r\n        # save_data = [self.x, yb]\r\n        # save_data = np.transpose(save_data)\r\n        # self.pw.save_to_file(\"Save background-corrected data in file\", startFileName, save_data)\r\n\r\n    def apply_call(self):\r\n        params = self.methods[self.blcm.current_method][\"parameter\"].values()\r\n        name = self.spectrum.get_label()\r\n        self.clear_plot()\r\n        for key, val in self.parameter_editor.items():\r\n            if key == \"roi\":\r\n                for i, roi_pe in enumerate(val):\r\n                    roi_start = float(roi_pe[0].text())\r\n                    roi_end = float(roi_pe[1].text())\r\n                    self.methods[self.blcm.current_method][\"parameter\"][\"roi\"][i] = [roi_start, roi_end]\r\n                    self.roi_spans.append(self.ax.axvspan(roi_start, roi_end, alpha=0.5, color=\"yellow\"))\r\n                self.methods[self.blcm.current_method][\"parameter\"][\"roi\"] = self.sort_roi(\r\n                    self.methods[self.blcm.current_method][\"parameter\"][\"roi\"])\r\n                continue\r\n            self.methods[self.blcm.current_method][\"parameter\"][key] = float(val.text())\r\n        return_value = self.methods[self.blcm.current_method][\"function\"](self.x, self.y, *params)\r\n        if return_value is None:\r\n            self.close()\r\n            return\r\n        else:\r\n            yb, zb = return_value\r\n        self.base_line, = self.ax.plot(self.x, zb, \"c--\", label=\"baseline ({})\".format(name))\r\n        self.blcSpektrum, = self.ax.plot(self.x, yb, \"c-\", label=\"baseline-corrected ({})\".format(name))\r\n        self.fig.canvas.draw()\r\n\r\n    def closeEvent(self, event):\r\n        self.clear_plot()\r\n        event.accept()\r\n\r\n\r\nclass FitFunctions:\r\n    \"\"\"\r\n    Fit functions\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        # number of fit functions\r\n        self.n_fit_fct = {\"Lorentz\": 0,\r\n                          \"Gauss\": 0,\r\n                          \"Breit-Wigner-Fano\": 0,\r\n                          \"Pseudo Voigt\": 0,\r\n                          \"Voigt\": 0}\r\n\r\n        self.function_parameters = {\r\n            \"Linear\": {\"slope\": [1, -np.inf, np.inf],\r\n                       \"intercept\": [0, -np.inf, np.inf]},\r\n            \"Lorentz\": {\"position\": [520, 0, np.inf],\r\n                        \"intensity\": [100, 0, np.inf],\r\n                        \"FWHM\": [15, 0, np.inf]},\r\n            \"Gauss\": {\"position\": [520, 0, np.inf],\r\n                      \"intensity\": [100, 0, np.inf],\r\n                      \"FWHM\": [15, 0, np.inf]},\r\n            \"Voigt\": {\"position\": [520, 0, np.inf],\r\n                      \"intensity\": [100, 0, np.inf],\r\n                      \"FWHM (Gauss)\": [15, 0, np.inf],\r\n                      \"FWHM (Lorentz)\": [15, 0, np.inf]},\r\n            \"Pseudo Voigt\": {\"position\": [520, 0, np.inf],\r\n                             \"intensity\": [100, 0, np.inf],\r\n                             \"FWHM (Gauss)\": [15, 0, np.inf],\r\n                             \"FWHM (Lorentz)\": [15, 0, np.inf],\r\n                             \"nu\": [0.5, 0, 1]},\r\n            \"Breit-Wigner-Fano\": {\"position\": [520, 0, np.inf],\r\n                                  \"intensity\": [100, 0, np.inf],\r\n                                  \"FWHM\": [15, 0, np.inf],\r\n                                  \"BWF coupling coefficient\": [-10, -np.inf, np.inf]}\r\n        }\r\n\r\n        self.implemented_functions = {\r\n            \"Linear\": self.LinearFct,\r\n            \"Lorentz\": self.LorentzFct,\r\n            \"Gauss\": self.GaussianFct,\r\n            \"Voigt\": self.VoigtFct,\r\n            \"Pseudo Voigt\": self.PseudoVoigt,\r\n            \"Breit-Wigner-Fano\": self.BreitWignerFct,\r\n        }\r\n\r\n    def LinearFct(self, x, a, b):\r\n        \"\"\" linear Function \"\"\"\r\n        return a * x + b\r\n\r\n    def LorentzFct(self, x, xc, h, b):\r\n        \"\"\" definition of Lorentzian for fit process \"\"\"\r\n        return h / (1 + (2 * (x - xc) / b) ** 2)\r\n\r\n    def GaussianFct(self, x, xc, h, b):\r\n        \"\"\" definition of Gaussian for fit process \"\"\"\r\n        return h * np.exp(-4 * math.log(2) * ((x - xc) / b) * ((x - xc) / b))\r\n\r\n    def BreitWignerFct(self, x, xc, h, b, Q):\r\n        \"\"\"definition of Breit-Wigner-Fano fucntion for fit process\r\n\r\n        (look e.g. \"Interpretation of Raman spectra of disordered and amorphous carbon\" von Ferrari und Robertson)\r\n        Q is BWF coupling coefficient\r\n        For Q^-1->0: the Lorentzian line is recovered\r\n        \"\"\"\r\n        return h * (1 + 2 * (x - xc) / (Q * b)) ** 2 / (1 + (2 * (x - xc) / b) ** 2)\r\n\r\n    def PseudoVoigt(self, x, xc, h, f_G, f_L, nu):\r\n        \"\"\"line profile pseudo function (linear combination of Lorentzian and Gaussian)\"\"\"\r\n        return nu * self.LorentzFct(x, xc, h, f_L) + (1 - nu) * self.GaussianFct(x, xc, h, f_G)\r\n\r\n    def VoigtFct(self, x, xc, h, f_G, f_L):\r\n        sigma = 1 / np.sqrt(8 * np.log(2)) * f_G\r\n        gamma = 1 / 2 * f_L\r\n        norm_factor = 5.24334\r\n        return norm_factor*h*sigma*special.voigt_profile(x-xc, sigma, gamma)\r\n\r\n    def FctSumme(self, x, *p):\r\n        \"\"\"\r\n        Summing up the fit functions\r\n        @param x: x data\r\n        @param p: fitparameter\r\n        @return: fitted y data\r\n        \"\"\"\r\n        y_sum = np.full(len(x), p[0])\r\n        n_para = 1\r\n        for key, val in self.n_fit_fct.items():\r\n            for i in range(val):\r\n                start = n_para\r\n                end = start + len(self.function_parameters[key])\r\n                params = p[start: end]\r\n                y_fct = self.implemented_functions[key](x, *params)\r\n                n_para = end\r\n                y_sum += y_fct\r\n        return y_sum\r\n\r\n\r\nclass FitOptionsDialog(QMainWindow):\r\n    closeSignal = QtCore.pyqtSignal()  # Signal in case Fit-parameter window is closed\r\n\r\n    def __init__(self, parent, x, y, spect):\r\n        \"\"\"\r\n        Options Dialog for fit process\r\n\r\n        Parameters\r\n        ----------\r\n        parent: PlotWindow object\r\n        x: x data / Raman shift\r\n        y: y data / Raman intensity\r\n        spect: Line2D\r\n        \"\"\"\r\n        super(FitOptionsDialog, self).__init__(parent=parent)\r\n        self.parent = parent\r\n        self.x = x\r\n        self.y = y\r\n        self.spectrum = spect\r\n\r\n        # get canvas, axes and figure object of parent\r\n        self.canvas = self.parent.canvas\r\n        self.ax = self.parent.ax\r\n        self.fig = self.parent.fig\r\n\r\n        # define variables\r\n        # plotted function\r\n        self.plotted_functions = []\r\n        # list of vertical headers\r\n        self.vheaders = [\"0\"]\r\n\r\n        self.used_functions = []\r\n        self.fit_functions = FitFunctions()\r\n\r\n        # create actual window\r\n        self.create_dialog()\r\n        self.create_menubar()\r\n\r\n    def create_dialog(self):\r\n        self.layout = QtWidgets.QVBoxLayout()\r\n\r\n        button_layout_01 = QtWidgets.QHBoxLayout()\r\n        button_layout_02 = QtWidgets.QHBoxLayout()\r\n\r\n        # Button to add Fit function\r\n        add_button = QPushButton(\"Add Function\")\r\n        add_button.clicked.connect(lambda: self.add_function(\r\n            \"Lorentz\", None))\r\n        button_layout_01.addWidget(add_button)\r\n\r\n        # Button to remove fit function\r\n        remove_button = QPushButton(\"Remove Function\")\r\n        remove_button.clicked.connect(self.remove_function)\r\n        button_layout_01.addWidget(remove_button)\r\n\r\n        # Fit Button => accept start values for fit\r\n        fit_button = QPushButton(\"Fit\")\r\n        fit_button.clicked.connect(self.fit)\r\n        button_layout_02.addWidget(fit_button)\r\n\r\n        # Apply\r\n        apply_button = QPushButton(\"Apply\")\r\n        apply_button.clicked.connect(self.apply)\r\n        button_layout_02.addWidget(apply_button)\r\n\r\n        self.layout.addLayout(button_layout_01)\r\n        self.layout.addLayout(button_layout_02)\r\n\r\n        # create table\r\n        self.table = QtWidgets.QTableWidget(1, 5)\r\n        self.table.itemChanged.connect(self.value_changed)\r\n\r\n        # set items in each cell\r\n        for r in range(self.table.rowCount()):\r\n            for c in range(self.table.columnCount()):\r\n                cell = QtWidgets.QTableWidgetItem(\"\")\r\n                self.table.setItem(r, c, cell)\r\n\r\n        # set headers\r\n        self.table.setHorizontalHeaderLabels([\"Fit Function\", \"Parameter\", \"Value\", \"Lower Bound\", \"Upper Bound\"])\r\n        self.table.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeToContents)\r\n        self.table.setVerticalHeaderLabels(self.vheaders)\r\n\r\n        # background\r\n        self.table.item(0, 0).setFlags(Qt.NoItemFlags)  # no interaction with this cell\r\n        self.table.item(0, 1).setText(\"background\")\r\n        self.table.item(0, 1).setFlags(Qt.NoItemFlags)\r\n        self.background = self.table.item(0, 2)\r\n        self.background.setText(str(0.0))\r\n\r\n        # bounds\r\n        self.table.item(0, 3).setText(str(-np.inf))\r\n        self.table.item(0, 4).setText(str(np.inf))\r\n\r\n        self.layout.addWidget(self.table)\r\n\r\n        widget = QtWidgets.QWidget()\r\n        widget.setLayout(self.layout)\r\n        self.setCentralWidget(widget)\r\n        self.setWindowTitle(\"Fit Functions\")\r\n        self.setWindowModality(Qt.ApplicationModal)\r\n\r\n    def create_menubar(self):\r\n        self.menubar = self.menuBar()\r\n        fileMenu = self.menubar.addMenu(\"File\")\r\n        fileMenu.addAction(\"Save Fit Parameter\", self.save_fit_parameter)\r\n        fileMenu.addAction(\"Load Fit Parameter\", self.load_fit_parameter)\r\n\r\n    def add_function(self, fct_name, fct_value):\r\n        \"\"\"\r\n        add fit function to table\r\n        \"\"\"\r\n\r\n        self.used_functions.append({})\r\n\r\n        # get parameters of function\r\n        if fct_value is None:\r\n            parameters = self.fit_functions.function_parameters[fct_name]\r\n        else:\r\n            parameters = fct_value\r\n        add_rows = len(parameters)\r\n\r\n        self.table.setRowCount(self.table.rowCount() + add_rows)\r\n        self.vheaders.extend([str(len(self.used_functions))]*add_rows)\r\n        self.table.setVerticalHeaderLabels(self.vheaders)\r\n\r\n        rows = self.table.rowCount()\r\n\r\n        # set items in new cell\r\n        for r in range(rows - add_rows, rows):\r\n            for c in range(self.table.columnCount()):\r\n                cell = QtWidgets.QTableWidgetItem('')\r\n                self.table.setItem(r, c, cell)\r\n\r\n        # add Combobox to select fit function\r\n        cbox = QtWidgets.QComboBox(self)\r\n        for key in self.fit_functions.n_fit_fct.keys():\r\n            cbox.addItem(key)\r\n        cbox.setCurrentText(fct_name)\r\n        n_fct = len(self.used_functions)\r\n        cbox.currentTextChanged.connect(lambda: self.fct_change(cbox.currentText(), n_fct-1))\r\n        self.table.setCellWidget(rows - add_rows, 0, cbox)\r\n        self.used_functions[-1][\"fct\"] = cbox\r\n\r\n        # configurate cells\r\n        self.table.item(rows - 2, 0).setFlags(Qt.NoItemFlags)  # no interaction with these cells\r\n        self.table.item(rows - 1, 0).setFlags(Qt.NoItemFlags)\r\n        self.used_functions[-1][\"parameter\"] = {}\r\n        for i, (key, val) in enumerate(parameters.items()):\r\n            self.table.item(rows - add_rows + i, 1).setText(key)\r\n            self.table.item(rows - add_rows + i, 1).setFlags(Qt.NoItemFlags)\r\n            self.table.item(rows - add_rows + i, 2).setText(str(val[0]))  # starting value\r\n            self.table.item(rows - add_rows + i, 3).setText(str(val[1]))  # lower bound\r\n            self.table.item(rows - add_rows + i, 4).setText(str(val[2]))  # upper bound\r\n            self.used_functions[-1][\"parameter\"][key] = {\r\n                \"value\": self.table.item(rows - add_rows + i, 2),\r\n                \"lower boundaries\": self.table.item(rows - add_rows + i, 3),\r\n                \"upper boundaries\": self.table.item(rows - add_rows + i, 4),\r\n            }\r\n\r\n    def remove_function(self):\r\n        last_key = len(self.used_functions)\r\n        row_indices = [i for i, x in enumerate(self.vheaders) if x == str(last_key)]\r\n        for j in reversed(row_indices):\r\n            del self.vheaders[j]\r\n            self.table.removeRow(j)\r\n        del self.used_functions[last_key-1]\r\n\r\n    def fct_change(self, fct_name, n):\r\n        old_parameters = self.used_functions[n][\"parameter\"].keys()\r\n        new_parameters = self.fit_functions.function_parameters[fct_name].keys()\r\n\r\n        for del_para in list(set(old_parameters) - set(new_parameters)):\r\n            # get index of row\r\n            row_index = self.vheaders.index(str(n + 1)) + len(new_parameters)\r\n            for item in self.table.findItems(del_para, QtCore.Qt.MatchExactly):\r\n                try:\r\n                    end = self.vheaders.index(str(n+2))\r\n                except ValueError:\r\n                    end = len(self.vheaders)+1\r\n                if self.vheaders.index(str(n + 1)) <= self.table.row(item) < end:\r\n                    row_index = self.table.row(item)\r\n                else:\r\n                    continue\r\n            # delete row and dictionary entry\r\n            del self.vheaders[row_index]\r\n            self.table.removeRow(row_index)\r\n            del self.used_functions[n][\"parameter\"][del_para]\r\n\r\n        row_index = self.vheaders.index(str(n + 1)) + len(old_parameters)\r\n        for new_para in [element for element in new_parameters if element not in old_parameters]:\r\n            self.table.insertRow(row_index)\r\n            self.vheaders.insert(row_index, str(n+1))\r\n            self.table.setVerticalHeaderLabels(self.vheaders)\r\n\r\n            # set items in new cell\r\n            for c in range(self.table.columnCount()):\r\n                cell = QTableWidgetItem(\"\")\r\n                self.table.setItem(row_index, c, cell)\r\n            self.table.item(row_index, 1).setText(new_para)\r\n            self.table.item(row_index, 1).setFlags(Qt.NoItemFlags)\r\n            self.table.item(row_index, 2).setText(str(self.fit_functions.function_parameters[fct_name][new_para][0]))\r\n\r\n            # boundaries\r\n            self.table.item(row_index, 3).setText(str(self.fit_functions.function_parameters[fct_name][new_para][1]))\r\n            self.table.item(row_index, 4).setText(str(self.fit_functions.function_parameters[fct_name][new_para][2]))\r\n\r\n            # update dictionary\r\n            self.used_functions[n][\"parameter\"][new_para] = {\r\n                \"value\": self.table.item(row_index, 2),\r\n                \"lower boundaries\": self.table.item(row_index, 3),\r\n                \"upper boundaries\": self.table.item(row_index, 4)\r\n            }\r\n            row_index += 1\r\n\r\n    def value_changed(self, item):\r\n        if item is None or self.table.item(item.row(), 3) is None or self.table.item(item.row(), 4) is None:\r\n            return\r\n        elif item.text() == '' or self.table.item(item.row(), 3).text() == '' or \\\r\n                self.table.item(item.row(), 4).text() == '':\r\n            return\r\n        else:\r\n            pass\r\n        # check that lower bound is strictly less than upper bound\r\n        if item.column() == 3:\r\n            if float(item.text()) > float(self.table.item(item.row(), 4).text()):\r\n                self.parent.mw.show_statusbar_message('Lower bounds have to be strictly less than upper bounds', 4000,\r\n                                                      error_sound=True)\r\n                # add: replace item with old previous item\r\n        elif item.column() == 4:  # check that upper bound is strictly higher than lower bound\r\n            if float(item.text()) < float(self.table.item(item.row(), 3).text()):\r\n                self.parent.mw.show_statusbar_message('Upper bounds have to be strictly higher than lower bounds', 4000,\r\n                                                      error_sound=True)\r\n                # add: replace item with old previous item\r\n\r\n    def save_fit_parameter(self):\r\n        \"\"\"Save fit parameter in txt file\"\"\"\r\n\r\n        # Get fit_parameter in printable form\r\n        print_table, r_squared = self.print_fitparameter()\r\n\r\n        # Save fit parameter in file\r\n        save_data = print_table.get_string()\r\n        filename = self.spectrum.get_label()\r\n        # startFileDirName = os.path.dirname(self.parent.mw.pHomeRmn)\r\n        # filename = '{}/{}_fitparameter.txt'.format(startFileDirName, filename)\r\n        # filename = \"\"\r\n        self.parent.save_to_file('Save fit parameter in file', filename, save_data)\r\n\r\n    def load_fit_parameter(self):\r\n        load_filename = QtWidgets.QFileDialog.getOpenFileName(self, 'Load fit parameter')\r\n        if load_filename[0] != '':\r\n            filename = load_filename[0]\r\n        else:\r\n            return\r\n\r\n        table_content = np.genfromtxt(filename, dtype='str', delimiter='|', skip_header=3, skip_footer=1,\r\n                                      usecols=(1, 2, 3), autostrip=True)\r\n\r\n        # set Background\r\n        self.table.item(0, 1).setText(str(table_content[0][2]))  # starting parameter\r\n\r\n        # delete background from table content\r\n        table_content = np.delete(table_content, 0, axis=0)\r\n\r\n        fct_value = {}\r\n        row = 0\r\n        fct_name = None\r\n        while row < len(table_content):\r\n            if all(tr == \"\" for tr in table_content[row]):\r\n                if fct_value:\r\n                    print(fct_value)\r\n                    self.add_function(fct_name, fct_value)\r\n                if row == len(table_content)-1:\r\n                    break\r\n                fct_name = table_content[row+1][0][:-2]\r\n                row += 2\r\n                fct_value = {}\r\n            else:\r\n                if table_content[row][0] == \"area under curve\":\r\n                    pass\r\n                else:\r\n                    fct_value[table_content[row][0]]=[table_content[row][1], 0, np.inf]\r\n                row += 1\r\n\r\n    def apply(self):\r\n        self.clear_plot()\r\n        p_start, boundaries = self.get_fit_parameter()\r\n        self.plot_functions(p_start)\r\n\r\n    def fit(self):\r\n        self.reset_n_fit_fct()\r\n        self.clear_plot()\r\n        p_start, boundaries = self.get_fit_parameter()\r\n        try:\r\n            popt, pcov = curve_fit(self.fit_functions.FctSumme, self.x, self.y, p0=p_start, bounds=boundaries)\r\n        except RuntimeError as e:\r\n            self.parent.mw.show_statusbar_message(str(e), 4000)\r\n            return\r\n        except ValueError as e:\r\n            self.parent.mw.show_statusbar_message(str(e), 4000)\r\n            return\r\n\r\n        self.plot_functions(popt, store_line=True)\r\n        self.set_fit_parameter(popt)\r\n        print_table, r_squared = self.print_fitparameter(popt=popt, pcov=pcov)\r\n        print('\\n {}'.format(self.spectrum.get_label()))\r\n        print(r'R^2={:.4f}'.format(r_squared))\r\n        print(print_table)\r\n\r\n    def set_fit_parameter(self, parameter):\r\n        self.background.setText(str(parameter[0]))\r\n\r\n        for i in range(1, len(parameter)):\r\n            self.table.item(i, 2).setText(str(parameter[i]))\r\n\r\n    def get_fit_parameter(self):\r\n        self.reset_n_fit_fct()\r\n\r\n        # Background\r\n        p_start = [float(self.background.text())]\r\n        bg_low = self.table.item(0, 3).text()\r\n        bg_up = self.table.item(0, 4).text()\r\n        if bg_low == \"\":\r\n            bg_low = -np.inf\r\n        else:\r\n            bg_low = float(bg_low)\r\n        if bg_up == \"\":\r\n            bg_up = np.inf\r\n        else:\r\n            bg_up = float(bg_up)\r\n        boundaries = [[bg_low], [bg_up]]\r\n\r\n        parameter = {_key: [] for _key in self.fit_functions.n_fit_fct.keys()}\r\n\r\n        lower_boundaries = {_key: [] for _key in self.fit_functions.n_fit_fct.keys()}\r\n        upper_boundaries = {_key: [] for _key in self.fit_functions.n_fit_fct.keys()}\r\n\r\n        for ufct in self.used_functions:\r\n            name_fct = ufct[\"fct\"].currentText()\r\n            for key, val in ufct[\"parameter\"].items():\r\n                parameter[name_fct].append(float(val[\"value\"].text()))  # Peak position in cm^-1\r\n                if val[\"lower boundaries\"].text()== '':\r\n                    lower_boundaries[name_fct].append(-np.inf)\r\n                else:\r\n                    lower_boundaries[name_fct].append(float(val[\"lower boundaries\"].text()))\r\n                if val[\"upper boundaries\"].text() == '':\r\n                    upper_boundaries[name_fct].append(np.inf)\r\n                else:\r\n                    upper_boundaries[name_fct].append(float(val[\"upper boundaries\"].text()))\r\n\r\n            self.fit_functions.n_fit_fct[name_fct] += 1\r\n\r\n        for p in parameter.values():\r\n            p_start.extend(p)\r\n\r\n        for lb, ub in zip(lower_boundaries.values(), upper_boundaries.values()):\r\n            boundaries[0].extend(lb)\r\n            boundaries[1].extend(ub)\r\n\r\n        return p_start, boundaries\r\n\r\n    def plot_functions(self, param, store_line=False):\r\n        x1 = np.linspace(min(self.x), max(self.x), int((max(self.x)-min(self.x))*5))\r\n        y_fit = self.fit_functions.FctSumme(x1, *param)\r\n        line, = self.ax.plot(x1, y_fit, \"-r\")\r\n        self.plotted_functions.append(line)\r\n        if store_line is True:\r\n            label = \"{} (fit)\".format(self.spectrum.get_label())\r\n            line.set_label(label)\r\n            self.parent.data.append(self.parent.create_data(x1, y_fit, line=line, label=label, style=\"-\"))\r\n        n_param = 1\r\n        for key in self.fit_functions.n_fit_fct.keys():\r\n            for i in range(self.fit_functions.n_fit_fct[key]):\r\n                start = n_param\r\n                end = start + len(self.fit_functions.function_parameters[key])\r\n                params = param[start: end]\r\n                y_fit = self.fit_functions.implemented_functions[key](x1, *params)\r\n                line, = self.ax.plot(x1, y_fit, \"--g\")\r\n                self.plotted_functions.append(line)\r\n                n_param = end\r\n                if store_line is True:\r\n                    label = \"{} {}\".format(key, i)\r\n                    line.set_label(label)\r\n                    self.parent.data.append(self.parent.create_data(x1, y_fit, line=line, label=label, style=\"-\"))\r\n\r\n        self.canvas.draw()\r\n\r\n    def clear_plot(self):\r\n        for pf in self.plotted_functions:\r\n            try:\r\n                pf.remove()\r\n            except ValueError as e:\r\n                print(\"Line couldn't be removed: {}\".format(e))\r\n                continue\r\n        self.plotted_functions = []\r\n        self.canvas.draw()\r\n\r\n    def print_fitparameter(self, popt=None, pcov=None):\r\n        \"\"\"bring fit parameter in printable form\"\"\"\r\n\r\n        # Get data from table\r\n        if popt is None:\r\n            popt = []\r\n            for r in range(self.table.rowCount()):\r\n                popt.append(float(self.table.item(r, 2).text()))\r\n\r\n        # Calculate Errors and R square\r\n        if pcov is not None:\r\n            perr = np.sqrt(np.diag(pcov))\r\n            residuals = self.y - self.fit_functions.FctSumme(self.x, *popt)\r\n            ss_res = np.sum(residuals ** 2)\r\n            ss_tot = np.sum((self.y - np.mean(self.y)) ** 2)\r\n            r_squared = 1 - (ss_res / ss_tot)\r\n        else:\r\n            r_squared = None\r\n            perr = [\"\"]*len(popt)\r\n\r\n        print_table = prettytable.PrettyTable()\r\n        print_table.field_names = [\"Parameters\", \"Values\", \"Errors\"]\r\n        print_table.add_rows([[\"background\", popt[0], perr[0]], [\"\", \"\", \"\"]])\r\n        a = 1\r\n        for key in self.fit_functions.n_fit_fct.keys():  # iterate over Lorentz, Gauss, BWF\r\n            for j in range(self.fit_functions.n_fit_fct[key]):  # iterate over used fit functions per L, G or BWF\r\n                print_table.add_row([\"{} {}\".format(key, j + 1), \"\", \"\"])\r\n                params = popt[a: a + len(self.fit_functions.function_parameters[key])]\r\n                area = np.trapz(self.fit_functions.implemented_functions[key](self.x, *params), self.x)\r\n                for parameter in self.fit_functions.function_parameters[key].keys():\r\n                    print_table.add_row([parameter, popt[a], perr[a]])\r\n                    a += 1\r\n                print_table.add_rows([[\"area under curve\", area, \"\"], [\"\", \"\", \"\"]])\r\n\r\n        return print_table, r_squared\r\n\r\n    def reset_n_fit_fct(self):\r\n        self.fit_functions.n_fit_fct = dict.fromkeys(self.fit_functions.n_fit_fct, 0)\r\n\r\n    def closeEvent(self, event):\r\n        self.reset_n_fit_fct()\r\n        self.closeSignal.emit()\r\n        event.accept\r\n\r\n\r\nclass MyCustomToolbar(NavigationToolbar2QT):\r\n    signal_remove_line = QtCore.pyqtSignal(object)\r\n    signal_axis_break = QtCore.pyqtSignal(list, list)\r\n\r\n    toolitems = [t for t in NavigationToolbar2QT.toolitems]\r\n    # Add new toolitem at last position\r\n    toolitems.append((\"Layers\", \"manage layers and layer contents\", \"Layer\", \"layer_content\"))\r\n\r\n    def __init__(self, plotCanvas):\r\n        NavigationToolbar2QT.__init__(self, plotCanvas, parent=None)\r\n        self.setWindowTitle(\"Top Toolbar\")\r\n\r\n    def layer_content(self):\r\n        Layer_Legend = QDialog()\r\n        layout = QtWidgets.QGridLayout()\r\n        Layer_Legend.setLayout(layout)\r\n        Layer_Legend.setWindowTitle(\"Layer Content\")\r\n        Layer_Legend.setWindowModality(Qt.ApplicationModal)\r\n        Layer_Legend.exec_()\r\n\r\n    def edit_parameters(self):\r\n        axes = self.canvas.figure.get_axes()\r\n        if not axes:\r\n            QtWidgets.QMessageBox.warning(self.canvas.parent(), \"Error\", \"There are no axes to edit.\")\r\n            return\r\n        figureoptions.figure_edit(axes, self)\r\n\r\n    def save_figure(self, *args):\r\n        # keep the default behaviour\r\n        super(MyCustomToolbar, self).save_figure(*args)\r\n\r\n    def _icon(self, name, *args):\r\n        if name == 'Layer.png':\r\n            return QIcon(os.path.dirname(os.path.realpath(__file__)) + \"/Icons/Layer_content.png\")\r\n        else:\r\n            return super(MyCustomToolbar, self)._icon(name, *args)\r\n\r\n\r\nclass PlotWindow(QMainWindow):\r\n    \"\"\"\r\n    Parameters\r\n    ----------\r\n    plot_data: array containing dict\r\n    \"\"\"\r\n\r\n    closeWindowSignal = QtCore.pyqtSignal(str, str)  # Signal in case plotwindow is closed\r\n\r\n    def __init__(self, plot_data, fig, parent):\r\n        super(PlotWindow, self).__init__(parent)\r\n        self.fig = fig\r\n        self.data = plot_data\r\n        self.mw = parent\r\n        self.vertical_line = None\r\n        self.functions = FitFunctions()\r\n        self.blc = BaselineCorrectionMethods()       # class for everything related to Baseline corrections\r\n        self.inserted_text = []  # Storage for text inserted in the plot\r\n        self.drawn_line = []  # Storage for lines and arrows drawn in the plot\r\n        self.peak_positions = {} # dict to store Line2D object marking peak positions\r\n\r\n        self.plot()\r\n        self.create_statusbar()\r\n        self.create_menubar()\r\n        self.create_sidetoolbar()\r\n\r\n        # self.cid1 = self.fig.canvas.mpl_connect('button_press_event', self.mousePressEvent)\r\n        # self.cid2 = self.fig.canvas.mpl_connect('key_press_event', self.keyPressEvent)\r\n        self.cid3 = self.fig.canvas.mpl_connect('pick_event', self.pickEvent)\r\n\r\n    def plot(self):\r\n        self.main_widget = QtWidgets.QWidget()\r\n        self.setCentralWidget(self.main_widget)\r\n        layout = QtWidgets.QVBoxLayout(self.main_widget)\r\n        legendfontsize = 24\r\n        labelfontsize = 24\r\n        tickfontsize = 18\r\n\r\n        if self.fig is None:  # new Plot\r\n            self.fig = Figure(figsize=(15, 9))\r\n            self.ax = self.fig.add_subplot(111)\r\n            self.canvas = FigureCanvasQTAgg(self.fig)\r\n            layout.addWidget(self.canvas)\r\n\r\n            for d in self.data:\r\n                if d[\"yerr\"] is not None:  # errors\r\n                    (spect, capline, barlinecol) = self.ax.errorbar(d[\"x\"], d[\"y\"], yerr=d[\"yerr\"], fmt=d[\"plot type\"],\r\n                                                                    picker=True, pickradius=5, capsize=3,\r\n                                                                    label='_Hidden errorbar {}'.format(d[\"label\"]))\r\n                    d[\"line\"] = spect\r\n                    spect.set_label(d[\"label\"])\r\n                else:\r\n                    d[\"line\"], = self.ax.plot(d[\"x\"], d[\"y\"], d[\"plot type\"], label=d[\"label\"],\r\n                                              picker=True, pickradius=5)\r\n            self.ax.legend(fontsize=legendfontsize)\r\n            if self.data[0][\"xaxis\"] is None:\r\n                self.data[0][\"xaxis\"] = r'Raman shift / cm$^{-1}$'\r\n\r\n            if self.data[0][\"yaxis\"] is None:\r\n                self.data[0][\"yaxis\"] = r'Intensity / cts/s'\r\n\r\n            self.ax.set_xlabel(self.data[0][\"xaxis\"], fontsize=labelfontsize)\r\n            self.ax.set_ylabel(self.data[0][\"yaxis\"], fontsize=labelfontsize)\r\n            self.ax.xaxis.set_tick_params(labelsize=tickfontsize)\r\n            self.ax.yaxis.set_tick_params(labelsize=tickfontsize)\r\n        else:  # loaded Plot\r\n            self.ax = self.fig.axes[0]\r\n            self.canvas = FigureCanvasQTAgg(self.fig)\r\n            layout.addWidget(self.canvas)\r\n\r\n            it = []\r\n\r\n            for j in self.ax.get_children():\r\n                if type(j) == mpatches.FancyArrowPatch:  # all drawn lines and arrows\r\n                    self.drawn_line.append(LineDrawer(j))\r\n                elif type(j) == matplotlib.text.Annotation and j not in it:  # all inserted texts\r\n                    it.append(j)\r\n                    self.inserted_text.append(InsertText(j, self.mw))\r\n                else:\r\n                    pass\r\n            self.ax.get_legend()\r\n        toolbar = MyCustomToolbar(self.canvas)\r\n        toolbar.signal_remove_line.connect(self.remove_line)\r\n        toolbar.signal_axis_break.connect(self.axis_break)\r\n        self.addToolBar(toolbar)\r\n        self.ax.get_legend().set_picker(5)\r\n\r\n    def add_plot(self, new_data):\r\n        ls = self.data[0][\"line\"].get_linestyle()\r\n        ma = self.data[0][\"line\"].get_marker()\r\n\r\n        for d in new_data:\r\n            self.data.append(d)\r\n            if d[\"yerr\"] is not None:\r\n                (spect, capline, barlinecol) = self.ax.errorbar(d[\"x\"], d[\"y\"], yerr=d[\"yerr\"], picker=True,\r\n                                                                pickradius=5, capsize=3,\r\n                                                                label='_Hidden errorbar {}'.format(d[\"label\"]))\r\n                d[\"line\"] = spect\r\n                spect.set_label(d[\"label\"])\r\n            else:\r\n                spect, = self.ax.plot(d[\"x\"], d[\"y\"], label=d[\"label\"], picker=True, pickradius=5)\r\n                d[\"line\"] = spect\r\n            spect.set_linestyle(ls)\r\n            spect.set_marker(ma)\r\n            if ls is not None:\r\n                d[\"plot type\"] = ls\r\n            else:\r\n                d[\"plot type\"] = ma\r\n        handles, labels = self.ax.get_legend_handles_labels()\r\n        self.update_legend(handles, labels)\r\n        self.canvas.draw()\r\n\r\n    def remove_line(self, line):\r\n        \"\"\"\r\n        remove data from self.data after line was removed in figure options\r\n        \"\"\"\r\n        idx = 0\r\n        for d in self.data:\r\n            if d[\"line\"] == line:\r\n                break\r\n            idx += 1\r\n        try:\r\n            self.data.pop(idx)\r\n        except IndexError:\r\n            pass\r\n\r\n    def axis_break(self, old_lines, new_lines):\r\n        \"\"\"in case of axis breaks, new line objects (Line2D) are created, this function replaces old line objects in\r\n        self.data with new one\"\"\"\r\n        for d in self.data:\r\n            for ol, nl in zip(old_lines, new_lines[0]):\r\n                if ol == d[\"line\"]:\r\n                    d[\"line\"] = nl\r\n\r\n    def pickEvent(self, event):\r\n        if event.mouseevent.dblclick is True and event.artist == self.ax.get_legend():\r\n            Dialog_Legend = QDialog()\r\n            layout = QtWidgets.QGridLayout()\r\n            handles, labels = self.ax.get_legend_handles_labels()\r\n\r\n            LabelList = QtWidgets.QListWidget()\r\n            LabelList.setAcceptDrops(True)\r\n            LabelList.setDragEnabled(True)\r\n            LabelList.setDragDropMode(LabelList.InternalMove)\r\n\r\n            for j in labels:\r\n                LabelList.insertItem(1, j)\r\n\r\n            layout.addWidget(LabelList)\r\n\r\n            Dialog_Legend.setLayout(layout)\r\n            Dialog_Legend.setWindowTitle(\"Legend order\")\r\n            Dialog_Legend.setWindowModality(Qt.ApplicationModal)\r\n            Dialog_Legend.exec_()\r\n\r\n            LabelListItems = [LabelList.item(i).text() for i in range(LabelList.count())]\r\n            new_handles = []\r\n            new_labels = []\r\n            for j in LabelListItems:\r\n                for i in range(len(labels)):\r\n                    if j == labels[i]:\r\n                        new_handles.append(handles[i])\r\n                        new_labels.append(labels[i])\r\n\r\n            self.update_legend(new_handles, new_labels)\r\n            self.canvas.draw()\r\n        elif event.artist in [d[\"line\"] for d in self.data] and event.mouseevent.button == 3:\r\n            line_dialog = QMenu()\r\n            line_dialog.addAction(\"Go to Spreadsheet\", lambda: self.go_to_spreadsheet(event.artist))\r\n            point = self.mapToGlobal(\r\n                QtCore.QPoint(event.mouseevent.x, self.frameGeometry().height() - event.mouseevent.y))\r\n            line_dialog.exec_(point)\r\n        else:\r\n            pass\r\n\r\n    def update_legend(self, leg_handles, leg_labels):\r\n        if self.ax.get_legend() is not None:\r\n            old_legend = self.ax.get_legend()\r\n            leg_draggable = old_legend._draggable is not None\r\n            leg_ncol = old_legend._ncol\r\n            leg_fontsize = int(old_legend._fontsize)\r\n            leg_frameon = old_legend.get_frame_on()\r\n            leg_shadow = old_legend.shadow\r\n            leg_fancybox = type(old_legend.legendPatch.get_boxstyle())\r\n            leg_framealpha = old_legend.get_frame().get_alpha()\r\n            leg_picker = old_legend.get_picker()\r\n        else:\r\n            leg_draggable = False\r\n            leg_ncol = 1\r\n            leg_fontsize = 15\r\n            leg_frameon = True\r\n            leg_shadow = True\r\n            leg_fancybox = True\r\n            leg_framealpha = 0.5\r\n            leg_picker = 5\r\n\r\n        new_legend = self.ax.legend(leg_handles, leg_labels,\r\n                                    ncol=leg_ncol,\r\n                                    fontsize=float(leg_fontsize),\r\n                                    frameon=leg_frameon,\r\n                                    shadow=leg_shadow,\r\n                                    framealpha=leg_framealpha,\r\n                                    fancybox=leg_fancybox)\r\n\r\n        new_legend.set_picker(leg_picker)\r\n        new_legend.set_draggable(leg_draggable)\r\n\r\n    # Bars (menubar, toolbar, statusbar)\r\n    def create_menubar(self):\r\n        menubar = self.menuBar()\r\n        # 1. menu item: File\r\n        fileMenu = menubar.addMenu('&File')\r\n        fileMenu.addAction('Save to File', self.menu_save_to_file)\r\n\r\n        # 2. menu item: Edit\r\n        editMenu = menubar.addMenu('&Edit')\r\n\r\n        #editDelete = editMenu.addMenu('Delete broken pixel - LabRam')\r\n        #editDelete.addAction(\"532nm\")\r\n        #editDelete.addAction(\"633nm\")\r\n        #editDelete.triggered[QAction].connect(self.del_broken_pixel)\r\n\r\n        editDeletePixel = editMenu.addAction('Delete single datapoint', self.del_datapoint)\r\n        editDeletePixel.setStatusTip(\r\n            'Delete selected data point with Enter, Move with arrow keys, Press c to leave Delete-Mode')\r\n\r\n        edit_remove_spikes = editMenu.addAction(\"Remove cosmic spikes\", self.remove_cosmic_spikes)\r\n\r\n        editSelectArea = editMenu.addAction('Define data area', self.DefineArea)\r\n        editSelectArea.setStatusTip('Move area limit with left mouse click, set it fix with right mouse click')\r\n\r\n        edit_shift = editMenu.addAction(\"Shift spectrum to zero line\", self.shift_spectrum_to_zero)\r\n\r\n        editNorm = editMenu.addMenu('Normalize spectrum regarding ...')\r\n        editNorm.setStatusTip('Normalizes highest peak to 1')\r\n        editNorm.addAction('... highest peak', self.normalize)\r\n        editNorm.addAction('... selected peak', lambda: self.normalize(select_peak=True))\r\n\r\n        editAddSubAct = editMenu.addAction('Add up or subtract two spectra', self.add_subtract_spectra)\r\n\r\n        # 3. menu: Analysis\r\n        analysisMenu = menubar.addMenu('&Analysis')\r\n\r\n        # 3.1 Analysis Fit\r\n        analysisFit = analysisMenu.addMenu('&Fit')\r\n\r\n        analysisFitSingleFct = analysisFit.addMenu('&Quick Fit')\r\n        analysisFitSingleFct.addAction('Lorentz')\r\n        analysisFitSingleFct.addAction('Gauss')\r\n        analysisFitSingleFct.addAction('Breit-Wigner-Fano')\r\n        analysisFitSingleFct.triggered[QAction].connect(self.quick_fit)\r\n\r\n        analysisFit.addAction(\"Fit Dialog\", self.open_fit_dialog)\r\n\r\n        analysisRoutine = analysisMenu.addMenu('&Analysis routines')\r\n        analysisRoutine.addAction('D und G Bande', self.fit_D_G)\r\n        analysisRoutine.addAction('Fit Sulfur oxyanion spectrum', self.fit_sulfuroxyanion)\r\n        analysisRoutine.addAction('Get m/I(G) (Hydrogen content)', self.hydrogen_estimation)\r\n        analysisRoutine.addAction('Norm to water peak', self.norm_to_water)\r\n\r\n        # 3.2 Linear regression\r\n        analysisMenu.addAction('Linear regression', self.linear_regression)\r\n\r\n        # 3.3 Analysis baseline correction\r\n        analysisMenu.addAction('Baseline Corrections', self.baseline)\r\n\r\n        # 3.3 Smoothing\r\n        analysisSmoothing = analysisMenu.addMenu('&Smoothing')\r\n        analysisSmoothing.addAction('Savitsky-Golay')\r\n        analysisSmoothing.addAction('Whittaker')\r\n        analysisSmoothing.triggered[QAction].connect(self.smoothing)\r\n\r\n        # 3.4 Analysis find peaks\r\n        analysisMenu.addAction('Find Peak', self.find_peaks)\r\n\r\n        # 3.5 Get Area below curve\r\n        analysisMenu.addAction('Get Area below Curve', self.detemine_area)\r\n\r\n        # 4. menu: spectra data base\r\n        databaseMenu = menubar.addAction('&Data base peak positions', self.open_peakdatabase)\r\n\r\n        self.show()\r\n\r\n    def create_statusbar(self):\r\n        self.statusBar = QtWidgets.QStatusBar()\r\n        self.setStatusBar(self.statusBar)\r\n        self.show()\r\n\r\n    def create_sidetoolbar(self):\r\n        toolbar = QtWidgets.QToolBar(\"Vertical Sidebar\", self)\r\n        self.addToolBar(QtCore.Qt.LeftToolBarArea, toolbar)\r\n\r\n        # Vertical line for comparison of peak positions\r\n        self.VertLineAct = QAction(QIcon(os.path.dirname(os.path.realpath(__file__)) + \"/Icons/Tool_Line.png\"),\r\n                              'Vertical Line', self)\r\n        self.VertLineAct.setStatusTip('Vertical line for comparison of peak position')\r\n        self.VertLineAct.triggered.connect(self.create_vertical_line)\r\n        self.VertLineAct.setCheckable(True)\r\n        toolbar.addAction(self.VertLineAct)\r\n\r\n        # Tool to scale intensity of selected spectrum\r\n        ScaleAct = QAction(QIcon(os.path.dirname(os.path.realpath(__file__)) + \"/Icons/Tool_Scale.png\"), 'Scale', self)\r\n        ScaleAct.setStatusTip('Tool to scale intensity of selected spectrum')\r\n        ScaleAct.triggered.connect(self.scale_spectrum)\r\n        toolbar.addAction(ScaleAct)\r\n\r\n        # Tool to shift selected spectrum in y-direction\r\n        ShiftAct = QAction(QIcon(os.path.dirname(os.path.realpath(__file__)) + \"/Icons/Tool_Shift.png\"), 'Shift', self)\r\n        ShiftAct.setStatusTip('Tool to shift selected spectrum in y-direction')\r\n        ShiftAct.triggered.connect(self.shift_spectrum)\r\n        toolbar.addAction(ShiftAct)\r\n\r\n        # Tool to draw line\r\n        DrawAct = QAction(QIcon(os.path.dirname(os.path.realpath(__file__)) + \"/Icons/Arrow.png\"), 'Draw', self)\r\n        DrawAct.setStatusTip('Tool to draw lines and arrows')\r\n        DrawAct.triggered.connect(self.draw_line)\r\n        toolbar.addAction(DrawAct)\r\n\r\n        # Tool to insert Text\r\n        TextAct = QAction(QIcon(os.path.dirname(os.path.realpath(__file__)) + \"/Icons/Tool_Text.png\"), 'Text', self)\r\n        TextAct.setStatusTip('Insert Text')\r\n        TextAct.triggered.connect(self.insert_text)\r\n        toolbar.addAction(TextAct)\r\n\r\n        self.show()\r\n\r\n    def create_data(self, x, y, yerr=None, line=None, style=\"-\", label=\"_newline\", filename=None, sstitle=None):\r\n        data_dict = {\"x\": x,\r\n                     \"y\": y,\r\n                     \"yerr\": yerr,\r\n                     \"line\": line,\r\n                     \"plot type\": style,\r\n                     \"label\": label,\r\n                     \"xaxis\": None,\r\n                     \"yaxis\": None,\r\n                     \"filename\": filename,\r\n                     \"spreadsheet title\": sstitle\r\n                     }\r\n        return data_dict\r\n\r\n    #### Functions and other stuff ####\r\n    def go_to_spreadsheet(self, line):\r\n        line_index =[d[\"line\"] for d in self.data].index(line)\r\n        if self.data[line_index][\"spreadsheet title\"]:\r\n            spreadsheet_name = self.data[line_index][\"spreadsheet title\"]\r\n            item = self.mw.treeWidget.findItems(spreadsheet_name, Qt.MatchFixedString | Qt.MatchRecursive)\r\n            for j in item:  # select spreadsheet if there are several items with same name\r\n                if j.type() == 1:\r\n                    spreadsheet_item = j\r\n                    break\r\n                else:\r\n                    continue\r\n            try:\r\n                self.mw.activate_window(spreadsheet_item)\r\n            except UnboundLocalError:\r\n                return\r\n            spreadsheet = self.mw.window['Spreadsheet'][spreadsheet_name]\r\n            header_name = self.data[line_index][\"label\"]\r\n            for j in range(spreadsheet.data_table.columnCount()):\r\n                if spreadsheet.header_table.horizontalHeaderItem(j).text() == header_name + ' (Y)':\r\n                    self.mw.show_statusbar_message(header_name, 4000)\r\n                    spreadsheet.header_table.setCurrentCell(0, j)\r\n                    break\r\n                else:\r\n                    continue\r\n\r\n        else:\r\n            self.mw.show_statusbar_message('OOPS! Something went wrong!', 3000)\r\n\r\n    def SelectDataset(self, select_only_one=False):\r\n        data_sets_name = []\r\n        self.selectedData = []\r\n        for d in self.data:\r\n            data_sets_name.append(d[\"line\"].get_label())\r\n        if len(data_sets_name) == 0:\r\n            self.selectedDatasetNumber = []\r\n        elif len(data_sets_name) == 1:\r\n            self.selectedDatasetNumber = [0]\r\n        else:\r\n            DSS = DataSetSelecter(data_sets_name, select_only_one)\r\n            self.selectedDatasetNumber = DSS.selectedDatasetNumber\r\n\r\n        for j in self.selectedDatasetNumber:\r\n            self.selectedData.append(self.data[j])\r\n\r\n    def menu_save_to_file(self):\r\n        self.SelectDataset()\r\n        for d in self.selectedData:\r\n            if d[\"filename\"] is not None:\r\n                startFileDirName = os.path.dirname(d[\"filename\"])\r\n                startFileName = '{}/{}'.format(startFileDirName, d[\"label\"])\r\n            else:\r\n                startFileName = None\r\n            save_data = [d[\"x\"], d[\"y\"]]\r\n            save_data = np.transpose(save_data)\r\n            self.save_to_file('Save data selected data in file', startFileName, save_data)\r\n\r\n    def save_to_file(self, WindowName, startFileName, data):\r\n        SaveFileName = QFileDialog.getSaveFileName(self, WindowName, startFileName, \"All Files (*);;Text Files (*.txt)\")\r\n        if SaveFileName[0] != '':\r\n            SaveFileName = SaveFileName[0]\r\n            if SaveFileName[-4:] == '.txt':\r\n                pass\r\n            else:\r\n                SaveFileName = str(SaveFileName) + '.txt'\r\n        else:\r\n            return\r\n\r\n        if isinstance(data, (np.ndarray, np.generic)):\r\n            np.savetxt(SaveFileName, data, fmt='%.5f')\r\n            np.savetxt(SaveFileName, data, fmt='%.5f')\r\n        else:\r\n            file = open(SaveFileName, 'w+')\r\n            file.write(data)\r\n            file.close()\r\n\r\n    def del_datapoint(self):\r\n        self.SelectDataset()\r\n        for j in self.selectedDatasetNumber:\r\n            pickDP = DataPointPicker(self.data[j][\"line\"], 0)\r\n            idx = pickDP.idx\r\n            self.data[j][\"x\"] = np.delete(self.data[j][\"x\"], idx)\r\n            self.data[j][\"y\"] = np.delete(self.data[j][\"y\"], idx)\r\n            self.data[j][\"line\"].set_data(self.data[j][\"x\"], self.data[j][\"y\"])\r\n            self.setFocus()\r\n            self.canvas.draw()\r\n\r\n    def del_broken_pixel(self, action):\r\n        \"\"\"\r\n        Deletes data point with number 630+n*957, because this pixel is broken in CCD detector of LabRam\r\n        \"\"\"\r\n        data_idx_diff = {'532nm': 957, '633nm': 924}\r\n        self.SelectDataset()\r\n        for j in self.selectedDatasetNumber:\r\n            data_idx = 629         # index of first broken data point\r\n            border = 6\r\n            print('Following data points of {} were deleted'.format(self.data[j][\"label\"]))\r\n            while data_idx <= len(self.data[j][\"x\"]):\r\n                data_min_idx = np.argmin(self.data[j][\"y\"][data_idx - border:data_idx + border])\r\n                if data_min_idx == 0 or data_min_idx == 2*border:\r\n                    QMessageBox.about(self, \"Title\",\r\n                                      \"Please select this data point manually (around {} in the data set {})\".format(\r\n                                          self.data[j][\"x\"][data_idx], self.data[j][\"y\"]))\r\n                    pickDP = DataPointPicker(self.data[j][\"line\"], data_idx)\r\n                    data_idx = pickDP.idx\r\n                else:\r\n                    data_idx += data_min_idx - border\r\n\r\n                print(self.data[j][\"x\"][data_idx], self.data[j][\"y\"][data_idx])\r\n                self.data[j][\"x\"] = np.round(np.delete(self.data[j][\"x\"], data_idx), 5)\r\n                self.data[j][\"y\"] = np.delete(self.data[j][\"y\"], data_idx)\r\n                data_idx += data_idx_diff[action.text()]\r\n\r\n            self.data[j][\"line\"].set_data(self.data[j][\"x\"], self.data[j][\"y\"])\r\n            self.setFocus()\r\n            self.canvas.draw()\r\n\r\n            # Save data without defective data points\r\n            startFileDirName = os.path.dirname(self.data[j][\"filename\"])\r\n            startFileName = startFileDirName + '/' + self.data[j][\"label\"]\r\n            save_data = [self.data[j][\"x\"], self.data[j][\"y\"]]\r\n            save_data = np.transpose(save_data)\r\n            self.save_to_file('Save data without deleted data points in file', startFileName, save_data)\r\n\r\n    def remove_cosmic_spikes(self):\r\n        \"\"\"\r\n        Remove cosmic spikes from Raman spectra\r\n        Whitaker, Darren A., and Kevin Hayes. \"A simple algorithm for despiking Raman spectra.\"\r\n        Chemometrics and Intelligent Laboratory Systems 179 (2018): 82-84.\r\n        @return: spectrum without spikes\r\n        \"\"\"\r\n        self.SelectDataset()\r\n        for n in self.selectedDatasetNumber:\r\n            y = self.data[n][\"y\"]\r\n            y_diff = np.diff(y)\r\n            z = (y_diff - np.median(y_diff)) / scipy.stats.median_abs_deviation(y_diff)\r\n            z = np.append(z, 0)\r\n\r\n            threshold = 8\r\n            z = (abs(z) > threshold) * 1\r\n            spikes = np.where(z == 1)\r\n            ma = 5\r\n\r\n            if spikes[0].size > 1:\r\n                print(\"{} contains cosmic spikes\".format(self.data[n][\"label\"]))\r\n\r\n            for i in spikes[0]:\r\n                w = np.arange(start=max([1, i - ma]), stop=min([len(y), i + ma]), step=1)\r\n                w = w[np.where(z[w] == 0)]\r\n                y[i] = np.mean(np.array(y)[w])\r\n\r\n            self.data[n][\"line\"].set_ydata(y)\r\n            self.data[n][\"y\"] = y\r\n        self.canvas.draw()\r\n\r\n    def normalize(self, select_peak=False):\r\n        \"\"\"\r\n        normalize spectrum regarding to highest peak or regarding selected peak\r\n        \"\"\"\r\n        self.SelectDataset()\r\n        for n in self.selectedDatasetNumber:\r\n            norm_factor = np.amax(self.data[n][\"y\"])\r\n            if select_peak:\r\n                dpp = DataPointPicker(self.data[n][\"line\"], np.where(self.data[n][\"y\"] == norm_factor))\r\n                idx = dpp.idx\r\n                norm_factor = self.data[n][\"y\"][idx]\r\n\r\n            self.data[n][\"y\"] = self.data[n][\"y\"] / norm_factor\r\n            self.data[n][\"line\"].set_data(self.data[n][\"x\"], self.data[n][\"y\"])\r\n            self.canvas.draw()\r\n            # Save normalized data\r\n            if self.data[n][\"filename\"] is not None:\r\n                (fileBaseName, fileExtension) = os.path.splitext(self.data[n][\"label\"])\r\n                startFileDirName = os.path.dirname(self.data[n][\"filename\"])\r\n                startFileBaseName = startFileDirName + '/' + fileBaseName\r\n                startFileName = startFileBaseName + '_norm.txt'\r\n            else:\r\n                startFileName = None\r\n            save_data = [self.data[n][\"x\"], self.data[n][\"y\"]]\r\n            save_data = np.transpose(save_data)\r\n            self.save_to_file('Save normalized data in file', startFileName, save_data)\r\n\r\n    def add_subtract_spectra(self):\r\n        \"\"\"\r\n        function to add or subtract a spectrum from an other spectrum\r\n        \"\"\"\r\n        self.dialog_add_sub = QDialog()\r\n        vlayout = QtWidgets.QVBoxLayout()\r\n        hlayout = QtWidgets.QHBoxLayout()\r\n\r\n        cbox_spectrum1 = QtWidgets.QComboBox(self.dialog_add_sub)\r\n        for d in self.data:\r\n            cbox_spectrum1.addItem(d[\"line\"].get_label())\r\n        hlayout.addWidget(cbox_spectrum1)\r\n\r\n        cbox_operation = QtWidgets.QComboBox(self.dialog_add_sub)\r\n        cbox_operation.addItem('+')\r\n        cbox_operation.addItem('-')\r\n        hlayout.addWidget(cbox_operation)\r\n\r\n        cbox_spectrum2 = QtWidgets.QComboBox(self.dialog_add_sub)\r\n        for d in self.data:\r\n            cbox_spectrum2.addItem(d[\"line\"].get_label())\r\n        hlayout.addWidget(cbox_spectrum2)\r\n\r\n        vlayout.addLayout(hlayout)\r\n\r\n        ok_button = QtWidgets.QPushButton('Ok')\r\n        ok_button.setFixedWidth(100)\r\n        vlayout.addWidget(ok_button)\r\n\r\n        ok_button.clicked.connect(self.dialog_add_sub.close)\r\n\r\n        self.dialog_add_sub.setLayout(vlayout)\r\n        self.dialog_add_sub.exec_()\r\n\r\n        sp1 = cbox_spectrum1.currentText()\r\n        i1 = cbox_spectrum1.currentIndex()\r\n        sp2 = cbox_spectrum2.currentText()\r\n        i2 = cbox_spectrum2.currentIndex()\r\n        op = cbox_operation.currentText()\r\n\r\n        x1 = self.data[i1][\"x\"]\r\n        x2 = self.data[i2][\"x\"]\r\n\r\n        # check that x data is the same\r\n        if (x1 == x2).all():\r\n            pass\r\n        else:\r\n            self.mw.show_statusbar_message('Not the same x data', 4000)\r\n            return\r\n\r\n        y1 = self.data[i1][\"y\"]\r\n        y2 = self.data[i2][\"y\"]\r\n\r\n        if op == '+':\r\n            y = y1 + y2\r\n            line_label = \"accumulated spectrum\"\r\n        elif op == '-':\r\n            y = y1 - y2\r\n            line_label = \"subtracted spectrum\"\r\n        else:\r\n            return\r\n\r\n        line_style = self.data[i1][\"line\"].get_linestyle()\r\n        line, = self.ax.plot(x1, y, label=line_label, linestyle=line_style)\r\n        self.data.append(self.create_data(x1, y, label=line_label, style=line_style, line=line))\r\n\r\n        self.canvas.draw()\r\n\r\n    def quick_fit(self, q):\r\n        self.SelectDataset()\r\n        if self.selectedDatasetNumber:\r\n            x_min, x_max = self.SelectArea()\r\n            self.functions.n_fit_fct[q.text()] = 1\r\n        else:\r\n            return\r\n\r\n        for j in self.selectedDatasetNumber:\r\n            xs = self.data[j][\"line\"].get_xdata()\r\n            ys = self.data[j][\"line\"].get_ydata()\r\n            x = xs[np.where((xs > x_min) & (xs < x_max))]\r\n            y = ys[np.where((xs > x_min) & (xs < x_max))]\r\n            idx_peaks, properties = signal.find_peaks(y, height=0.1 * max(y))\r\n            if idx_peaks.size > 0:\r\n                p = round(x[idx_peaks[0]], 2)\r\n                h = round(properties['peak_heights'][0], 2)\r\n                w = signal.peak_widths(y, idx_peaks)[0][0]\r\n            else:\r\n                self.mw.show_statusbar_message(\"Couldn't find good start parameters \\n\"\r\n                                               \"Use Fit Dialog please\", 4000)\r\n                return\r\n            p_start = [0, p, h, w]\r\n\r\n            try:\r\n                popt, pcov = curve_fit(self.functions.FctSumme, x, y, p0=p_start)\r\n            except RuntimeError or ValueError as e:\r\n                self.mw.show_statusbar_message(str(e), 4000)\r\n                self.functions.n_fit_fct = dict.fromkeys(self.functions.n_fit_fct, 0)\r\n                return\r\n            x1 = np.linspace(min(x), max(x), 1000)\r\n            y1 = self.functions.FctSumme(x1, *popt)\r\n            line, = self.ax.plot(x1, y1, '-r')\r\n            label = line.get_label()\r\n            self.data.append(self.create_data(x1, y1, label=label, style='-r', line=line))\r\n            self.canvas.draw()\r\n\r\n            print('\\n {} {}'.format(self.data[j][\"line\"].get_label(), q.text()))\r\n            parmeter_name = ['background', 'Raman Shift in cm^-1', 'Intensity', 'FWHM', 'additional Parameter']\r\n            print_param = []\r\n            for idx, po in enumerate(popt):\r\n                print_param.append([parmeter_name[idx], po])\r\n            print(tabulate(print_param, headers=['Parameters', 'Values']))\r\n\r\n        self.functions.n_fit_fct = dict.fromkeys(self.functions.n_fit_fct, 0)\r\n\r\n    def open_fit_dialog(self):\r\n        self.SelectDataset()\r\n        if self.selectedDatasetNumber:\r\n            x_min, x_max = self.SelectArea()\r\n\r\n        else:\r\n            return\r\n\r\n        for n in self.selectedDatasetNumber:\r\n            xs = self.data[n][\"line\"].get_xdata()\r\n            ys = self.data[n][\"line\"].get_ydata()\r\n            x = xs[np.where((xs > x_min) & (xs < x_max))]\r\n            y = ys[np.where((xs > x_min) & (xs < x_max))]\r\n\r\n            fit_dialog = FitOptionsDialog(self, x, y, self.data[n][\"line\"])\r\n            fit_dialog.setMinimumWidth(600)\r\n            fit_dialog.show()\r\n\r\n            loop = QtCore.QEventLoop()\r\n            fit_dialog.closeSignal.connect(loop.quit)\r\n            loop.exec_()\r\n\r\n    def DefineArea(self):\r\n        self.SelectDataset()\r\n        x_min, x_max = self.SelectArea()\r\n        for n in self.selectedDatasetNumber:\r\n            spct = self.data[n][\"line\"]\r\n            xs = spct.get_xdata()\r\n            ys = spct.get_ydata()\r\n            x = xs[np.where((xs > x_min) & (xs < x_max))]\r\n            y = ys[np.where((xs > x_min) & (xs < x_max))]\r\n\r\n            label = \"{}_cut\".format(spct.get_label())\r\n            line, = self.ax.plot(x, y, label=label, picker=True, pickradius=5)[0]\r\n            self.data.append(self.create_data(x, y, label=label, line=line, filename=self.selectedData[0][\"filename\"]))\r\n\r\n    def SelectArea(self):\r\n        self.ax.autoscale(False)\r\n        y_min, y_max = self.ax.get_ylim()\r\n        x_min, x_max = self.ax.get_xlim()\r\n        x_range = x_max-x_min\r\n        self.mw.show_statusbar_message('Left click shifts limits, Right click to finish', 4000)\r\n\r\n        line_1 = LineBuilder([x_min+0.01*x_range], [y_min, y_max], self.canvas)\r\n        line_2 = LineBuilder([x_max-0.01*x_range], [y_min, y_max], self.canvas, loop=True)\r\n\r\n        x_min = line_1.get_xdata()  # lower limit\r\n        x_max = line_2.get_xdata()  # upper limit\r\n\r\n        self.canvas.draw()\r\n        self.ax.autoscale(True)\r\n        return x_min, x_max\r\n\r\n    def detemine_area(self):\r\n        self.SelectDataset()\r\n        area = {}\r\n        for n in self.selectedDatasetNumber:\r\n            x = self.data[n][\"x\"]\r\n            y = self.data[n][\"y\"]\r\n            area[self.data[n][\"label\"]] = np.trapz(y, x)\r\n\r\n        print(area)\r\n        return area\r\n\r\n    def find_peaks(self):\r\n        self.SelectDataset()\r\n        for n in self.selectedDatasetNumber:\r\n            x = self.data[n][\"x\"]\r\n            y = self.data[n][\"y\"]\r\n            y_max = max(y)\r\n\r\n            idx_peaks, properties = signal.find_peaks(y, height=0.3 * y_max, width=5, distance=50)\r\n\r\n            print(x[idx_peaks])\r\n\r\n    def shift_spectrum_to_zero(self):\r\n        self.SelectDataset()\r\n        for n in self.selectedDatasetNumber:\r\n            spct = self.data[n][\"line\"]\r\n            xs = spct.get_xdata()\r\n            ys = spct.get_ydata()\r\n            min_y = min(ys)\r\n            y_shifted = ys-min_y\r\n            spct.set_ydata(y_shifted)\r\n            self.data[n][\"y\"] = y_shifted\r\n            self.canvas.draw()\r\n\r\n    def baseline(self):\r\n        self.SelectDataset()\r\n        x_min, x_max = self.SelectArea()\r\n        baseline_methods = BaselineCorrectionMethods()\r\n        for n in self.selectedDatasetNumber:\r\n            spct = self.data[n][\"line\"]\r\n            xs = spct.get_xdata()\r\n            ys = spct.get_ydata()\r\n\r\n            x = xs[np.where((xs > x_min) & (xs < x_max))]\r\n            y = ys[np.where((xs > x_min) & (xs < x_max))]\r\n\r\n            baseline_dialog = BaselineCorrectionsDialog(self, baseline_methods)\r\n            baseline_dialog.get_baseline(x, y, spct)\r\n\r\n            # wait until QMainWindow is closes\r\n            loop = QtCore.QEventLoop()\r\n            baseline_dialog.closebutton.clicked.connect(loop.quit)\r\n            baseline_dialog.finishbutton.clicked.connect(loop.quit)\r\n            loop.exec_()\r\n            if baseline_dialog.closebutton.isChecked():\r\n                break\r\n\r\n    def smoothing(self, action):\r\n        self.SelectDataset()\r\n        method = action.text()\r\n        for n in self.selectedDatasetNumber:\r\n            spct = self.data[n][\"line\"]\r\n            x = np.array(spct.get_xdata())\r\n            y = np.array(spct.get_ydata())\r\n            if method == \"Savitsky-Golay\":\r\n                y_smooth = rp.smooth(x, y, method=\"savgol\", window_length=15, polyorder=3)\r\n            elif method == \"Whittaker\":\r\n                y_smooth = rp.smooth(x, y, method=\"whittaker\", Lambda=10**0.5)\r\n            spct.set_ydata(y_smooth)\r\n            self.data[n][\"y\"] = y_smooth\r\n            self.canvas.draw()\r\n\r\n    def linear_regression(self):\r\n        self.SelectDataset()\r\n        for n in self.selectedDatasetNumber:\r\n            spct = self.data[n][\"line\"]\r\n            xs = spct.get_xdata()\r\n            ys = spct.get_ydata()\r\n\r\n            # delete all values, which are nan\r\n            x = xs[np.logical_not(np.isnan(ys))]\r\n            y = ys[np.logical_not(np.isnan(ys))]\r\n\r\n            # Fit\r\n            popt, pcov = curve_fit(self.functions.LinearFct, x, y)\r\n\r\n            # Errors and R**2\r\n            perr = np.sqrt(np.diag(pcov))\r\n            residuals = y - self.functions.LinearFct(x, *popt)\r\n            ss_res = np.sum(residuals ** 2)\r\n            ss_tot = np.sum((y - np.mean(y)) ** 2)\r\n            r_squared = 1 - (ss_res / ss_tot)\r\n\r\n            # Plot determined linear function\r\n            x1 = np.linspace(min(x), max(x), 1000)\r\n            y1 = self.functions.LinearFct(x1, *popt)\r\n            line, = self.ax.plot(x1, y1, '-r')\r\n            label = line.get_label()\r\n            self.data.append(self.create_data(x, y, label=label, line=line, style='-'))\r\n            self.canvas.draw()\r\n\r\n            # Print results\r\n            print('\\n {}'.format(spct.get_label()))\r\n            print(r'R^2={:.4f}'.format(r_squared))\r\n            parmeter_name = ['Slope', 'y-Intercept']\r\n            print_param = []\r\n            for i in range(len(popt)):\r\n                print_param.append([parmeter_name[i], popt[i], perr[i]])\r\n            print(tabulate(print_param, headers=['Parameters', 'Values', 'Errors']))\r\n\r\n    def hydrogen_estimation(self):\r\n        \"\"\"\r\n        determine the slope of PL background in carbon spectra in order to estimate the hydrogen content compare with:\r\n        C. Casiraghi, A. C. Ferrari, J. Robertson, Physical Review B 2005, 72, 8 085401.\r\n        \"\"\"\r\n\r\n        self.SelectDataset()\r\n        x_min_1 = 600\r\n        x_max_1 = 900\r\n        x_min_2 = 1900\r\n        x_max_2 = 2300\r\n        for n in self.selectedDatasetNumber:\r\n            x = self.data[n][\"x\"]\r\n            y = self.data[n][\"y\"]\r\n\r\n            x1 = x[np.where((x > x_min_1) & (x < x_max_1))]\r\n            y1 = y[np.where((x > x_min_1) & (x < x_max_1))]\r\n            x2 = x[np.where((x > x_min_2) & (x < x_max_2))]\r\n            y2 = y[np.where((x > x_min_2) & (x < x_max_2))]\r\n            x = np.concatenate((x1, x2))\r\n            y = np.concatenate((y1, y2))\r\n\r\n            popt, pcov = curve_fit(self.functions.LinearFct, x, y)\r\n\r\n            # Plot determined linear function\r\n            x_plot = np.linspace(min(x), max(x), 1000)\r\n            self.ax.plot(x_plot, self.functions.LinearFct(x_plot, *popt), '-r')\r\n            self.canvas.draw()\r\n\r\n            # get index of G peak\r\n            idx_G = np.argmax(y)\r\n\r\n            # calculate m/I(G):\r\n            mIG = popt[0] / y[idx_G]\r\n            if mIG > 0:\r\n                H_content = 21.7 + 16.6 * math.log(mIG * 10 ** 4)\r\n                print(mIG, H_content)\r\n            else:\r\n                print('negative slope')\r\n\r\n    def fit_D_G(self):\r\n        \"\"\"\r\n        Partially based on Christian's Mathematica Notebook\r\n        Fitroutine for D and G bands in spectra of carbon compounds\r\n        \"\"\"\r\n        # Select which data set will be fitted\r\n        self.SelectDataset()\r\n        # if self.selectedData == []:\r\n        #    return\r\n\r\n        # Limits for Backgroundcorrection\r\n        x_min = 200\r\n        x_max = 4000\r\n\r\n        # parameter for background-correction\r\n        p = 0.0005  # asymmetry 0.001 <= p <= 0.1 is a good choice  recommended from Eilers and Boelens for Raman: 0.001\r\n        # recommended from Simon: 0.0005\r\n        lam = 10000000  # smoothness 10^2 <= lambda <= 10^9         recommended from Eilers and Boelens for Raman: 10^7\r\n        # recommended from Simon: 10^7\r\n\r\n        # Limits for FitProcess\r\n        # define fitarea\r\n        x_min_fit = 945\r\n        x_max_fit = 1830\r\n\r\n        # Fitprocess\r\n        # D-Band: Lorentz\r\n        # G-Band: BreitWignerFano\r\n        self.fit_functions.n_fit_fct['Lorentz'] = 1  # number of Lorentzian\r\n        self.fit_functions.n_fit_fct['Gauss'] = 3  # number of Gaussian\r\n        self.fit_functions.n_fit_fct['Breit-Wigner-Fano'] = 1  # number of Breit-Wigner-Fano\r\n        aL = self.fit_functions.n_fit_fct['Lorentz']\r\n        aG = self.fit_functions.n_fit_fct['Gauss']\r\n        aB = self.fit_functions.n_fit_fct['Breit-Wigner-Fano']\r\n        aLG = self.fit_functions.n_fit_fct['Lorentz'] + self.fit_functions.n_fit_fct['Gauss']\r\n\r\n        # Fit parameter: initial guess and boundaries\r\n\r\n        pStart = []\r\n        pBoundsLow = []\r\n        pBoundsUp = []\r\n        inf = np.inf\r\n\r\n        pStart.append((1350, 150, 30))  # D-Bande\r\n        pBoundsLow.append((1335, 0, 0))\r\n        pBoundsUp.append((1385, inf, 150))\r\n\r\n        pStart.append((1160, 1, 5))  # additional Peak (PA)\r\n        pBoundsLow.append((1150, 0, 0))\r\n        pBoundsUp.append((1180, inf, 70))\r\n        pStart.append((1240, 0.1, 5))  # additional Peak (PA)\r\n        pBoundsLow.append((1225, 0, 0))\r\n        pBoundsUp.append((1255, inf, 100))\r\n        pStart.append((1430, 0.1, 5))  # additional Peak (PA)\r\n        pBoundsLow.append((1420, 0, 0))\r\n        pBoundsUp.append((1440, inf, 100))\r\n\r\n        pStart.append((1590, 200, 30, -10))  # G-Peak (BWF)\r\n        pBoundsLow.append((1575, 0, 0, -inf))\r\n        pBoundsUp.append((1630, inf, inf, inf))\r\n\r\n        p_start = []\r\n        p_bounds_low = []\r\n        p_bounds_up = []\r\n        p_start.extend([0])\r\n        p_bounds_low.extend([-10])\r\n        p_bounds_up.extend([inf])\r\n        for i in range(len(pStart)):\r\n            p_start.extend(pStart[i])\r\n            p_bounds_low.extend(pBoundsLow[i])\r\n            p_bounds_up.extend(pBoundsUp[i])\r\n\r\n        # Limits Fit parameter\r\n        p_bounds = ((p_bounds_low, p_bounds_up))\r\n\r\n        # iterate through all selected data sets\r\n        for n in self.selectedDatasetNumber:\r\n            x = self.data[n][\"x\"]\r\n            y = self.data[n][\"y\"]\r\n\r\n            # Limit data to fit range\r\n            working_x = x[np.where((x > x_min) & (x < x_max))]\r\n            working_y = y[np.where((x > x_min) & (x < x_max))]\r\n\r\n            yb, zb = self.blc.ALS(working_x, working_y, p, lam)\r\n            baseline, = self.ax.plot(working_x, zb, 'c--',\r\n                                     label='baseline ({})'.format(self.data[n][\"line\"].get_label()))\r\n            blcSpektrum, = self.ax.plot(working_x, yb, 'c-',\r\n                                        label='baseline-corrected ({})'.format(self.data[n][\"line\"].get_label()))\r\n            self.canvas.draw()\r\n\r\n            # limit data to fitarea\r\n            working_y = yb[np.where((working_x > x_min_fit) & (working_x < x_max_fit))]\r\n            working_x = working_x[np.where((working_x > x_min_fit) & (working_x < x_max_fit))]\r\n\r\n            try:\r\n                popt, pcov = curve_fit(self.functions.FctSumme, working_x, working_y, p0=p_start, bounds=p_bounds,\r\n                                       absolute_sigma=False)\r\n            except RuntimeError as e:\r\n                self.mw.show_statusbar_message(str(e), 4000)\r\n                continue\r\n\r\n            # Plot the Fit Data\r\n            x1 = np.linspace(min(working_x), max(working_x), 3000)\r\n            y_L = []\r\n            for j in range(aL):\r\n                y_L.append(np.array(\r\n                    popt[0] + self.functions.LorentzFct(x1, popt[1 + 3 * j], popt[2 + 3 * j], popt[3 + 3 * j])))\r\n            y_G = []\r\n            for j in range(aG):\r\n                y_G.append(np.array(\r\n                    popt[0] + self.functions.GaussianFct(x1, popt[1 + 3 * aL + 3 * j], popt[2 + 3 * aL + 3 * j],\r\n                                                         popt[3 + 3 * aL + 3 * j])))\r\n            y_BWF = []\r\n            for j in range(aB):\r\n                y_BWF.append(np.array(\r\n                    popt[0] + self.functions.BreitWignerFct(x1, popt[4 * j + 3 * aLG + 1], popt[4 * j + 3 * aLG + 2],\r\n                                                            popt[4 * j + 3 * aLG + 3], popt[4 * j + 3 * aLG + 4])))\r\n            y_Ges = np.array(self.functions.FctSumme(x1, *popt))\r\n            self.ax.plot(x1, y_Ges, '-r')\r\n            for j in y_G:\r\n                self.ax.plot(x1, j, '--g')\r\n            for j in y_L:\r\n                self.ax.plot(x1, j, '--g')\r\n            for j in y_BWF:\r\n                self.ax.plot(x1, j, '--g')\r\n\r\n            self.canvas.draw()\r\n\r\n            # Calculate Errors and R square\r\n            perr = np.sqrt(np.diag(pcov))\r\n\r\n            residuals = working_y - self.functions.FctSumme(working_x, *popt)\r\n            ss_res = np.sum(residuals ** 2)\r\n            ss_tot = np.sum((working_y - np.mean(working_y)) ** 2)\r\n            r_squared = 1 - (ss_res / ss_tot)\r\n\r\n            # Calculate Peak-Areas and there Errors\r\n            r, a0, h, xc, b, Q = sp.symbols('r a0 h xc b Q', real=True)\r\n\r\n            # Anti-Derivative of Lorentzian Function\r\n            F_L = (x_max_fit - x_min_fit) * a0 - b * h * sp.atan(2 * (xc - x_max_fit) / b) / 2 + b * h * sp.atan(\r\n                2 * (xc - x_min_fit) / b) / 2\r\n            Flam_L = lambdify([a0, xc, h, b], F_L)\r\n\r\n            # Anti-Derivative of Gaussian Function\r\n            F_G = (4 * a0 * (x_max_fit - x_min_fit) * sp.sqrt(sp.log(2)) - sp.sqrt(sp.pi) * b * h * sp.erf(\r\n                2 * (xc - x_max_fit) * sp.sqrt(sp.log(2)) / b) +\r\n                   sp.sqrt(sp.pi) * b * h * sp.erf(2 * (xc - x_min_fit) * sp.sqrt(sp.log(2)) / b)) / (\r\n                          4 * sp.sqrt(sp.log(2)))\r\n            Flam_G = lambdify([a0, xc, h, b], F_G)\r\n\r\n            # Anti-Derivative of Breit-Wigner-Fano Function\r\n            F_B = (Q * b * h * (sp.log(b ** 2 / 4 + xc ** 2 - 2 * xc * x_max_fit + x_max_fit ** 2) - sp.log(\r\n                b ** 2 / 4 + xc ** 2 - 2 * xc * x_min_fit + x_min_fit ** 2)) -\r\n                   b * h * (Q - 1) * (Q + 1) * sp.atan(2 * (xc - x_max_fit) / b) + b * h * (Q - 1) * (Q + 1) * sp.atan(\r\n                        2 * (xc - x_min_fit) / b) + 2 * x_max_fit * (Q ** 2 * a0 + h) - 2 * x_min_fit * (\r\n                           Q ** 2 * a0 + h)) / (2 * Q ** 2)\r\n            Flam_B = lambdify([a0, xc, h, b, Q], F_B)\r\n\r\n            # Calculate partial derivates\r\n            dF_La0 = sp.diff(F_L, a0)\r\n            dF_Lh = sp.diff(F_L, h)\r\n            dF_Lxc = sp.diff(F_L, xc)\r\n            dF_Lb = sp.diff(F_L, b)\r\n\r\n            dF_Ga0 = sp.diff(F_G, a0)\r\n            dF_Gh = sp.diff(F_G, h)\r\n            dF_Gxc = sp.diff(F_G, xc)\r\n            dF_Gb = sp.diff(F_G, b)\r\n\r\n            dF_Ba0 = sp.diff(F_B, a0)\r\n            dF_Bh = sp.diff(F_B, h)\r\n            dF_Bxc = sp.diff(F_B, xc)\r\n            dF_Bb = sp.diff(F_B, b)\r\n            dF_BQ = sp.diff(F_B, Q)\r\n\r\n            # Calculate Error of Peak Area with law of error propagation\r\n            da0, dh, dxc, db, dQ = sp.symbols('da0 dh dxc db dQ', real=True)\r\n\r\n            DeltaF_L = sp.Abs(dF_La0) * da0 + sp.Abs(dF_Lh) * dh + sp.Abs(dF_Lxc) * dxc + sp.Abs(dF_Lb) * db\r\n            DeltaFlam_L = lambdify([a0, da0, xc, dxc, h, dh, b, db], DeltaF_L)\r\n            DeltaF_G = sp.Abs(dF_Ga0) * da0 + sp.Abs(dF_Gh) * dh + sp.Abs(dF_Gxc) * dxc + sp.Abs(dF_Gb) * db\r\n            DeltaFlam_G = lambdify([a0, da0, xc, dxc, h, dh, b, db], DeltaF_G)\r\n            DeltaF_B = sp.Abs(dF_Ba0) * da0 + sp.Abs(dF_Bh) * dh + sp.Abs(dF_Bxc) * dxc + sp.Abs(dF_Bb) * db + sp.Abs(\r\n                dF_BQ) * dQ\r\n            DeltaFlam_B = lambdify([a0, da0, xc, dxc, h, dh, b, db, Q, dQ], DeltaF_B)\r\n\r\n            # Peak Area\r\n            area_D = 0\r\n            area_G = 0\r\n            area_D_err = 0\r\n            area_G_err = 0\r\n            pos_G = 1600\r\n            pos_G_err = 0\r\n            b_G = 0\r\n            q_G = 0\r\n\r\n            I_D = 0\r\n            I_G = 0\r\n\r\n            xD = 1350\r\n            xG = 1600\r\n            absxD = 1350\r\n            absxG = 1600\r\n\r\n            area_Lorentz = []\r\n            area_Lorentz_err = []\r\n            for j in range(aL):\r\n                area_Lorentz.append(Flam_L(popt[0], popt[1 + 3 * j], popt[2 + 3 * j], popt[3 + 3 * j]))\r\n                area_Lorentz_err.append(\r\n                    DeltaFlam_L(popt[0], perr[0], popt[3 * j + 1], perr[3 * j + 1], popt[3 * j + 2], perr[3 * j + 2],\r\n                                popt[3 * j + 3], perr[3 * j + 3]))\r\n                if np.abs(popt[1 + 3 * j] - xD) < absxD:\r\n                    area_D = area_Lorentz[j]\r\n                    area_D_err = area_Lorentz_err[j]\r\n                    absxD = np.abs(popt[1 + 3 * j] - xD)\r\n                    I_D = popt[2 + 3 * j]\r\n                elif np.abs(popt[1 + 3 * j] - xG) < absxG:\r\n                    area_G = area_Lorentz[j]\r\n                    area_G_err = area_Lorentz_err[j]\r\n                    absxG = np.abs(popt[1 + 3 * j] - xD)\r\n                    I_G = popt[2 + 3 * j]\r\n                    pos_G = popt[1 + 3 * j]\r\n                    pos_G_err = perr[1 + 3 * j]\r\n                    b_G = popt[3 + 3 * j]\r\n                    q_G = popt[4 + 3 * j]\r\n                else:\r\n                    pass\r\n\r\n            area_Gauss = []\r\n            area_Gauss_err = []\r\n            for j in range(aG):\r\n                area_Gauss.append(\r\n                    Flam_G(popt[0], popt[1 + 3 * aL + 3 * j], popt[2 + 3 * aL + 3 * j], popt[3 + 3 * aL + 3 * j]))\r\n                area_Gauss_err.append(DeltaFlam_G(popt[0], perr[0], popt[3 * j + 3 * aL + 1], perr[3 * j + 3 * aL + 1],\r\n                                                  popt[3 * j + 3 * aL + 2], perr[3 * j + 3 * aL + 2],\r\n                                                  popt[3 * j + 3 * aL + 3],\r\n                                                  perr[3 * j + 3 * aL + 3]))\r\n                if np.abs(popt[1 + 3 * aL + 3 * j] - xD) < absxD:\r\n                    area_D = area_Gauss[j]\r\n                    area_D_err = area_Gauss_err[j]\r\n                    absxD = np.abs(popt[1 + 3 * aL + 3 * j] - xD)\r\n                    I_D = popt[2 + 3 * aL + 3 * j]\r\n                elif np.abs(popt[1 + 3 * aL + 3 * j] - xG) < absxG:\r\n                    area_G = area_Gauss[j]\r\n                    area_G_err = area_Gauss_err[j]\r\n                    absxG = np.abs(popt[1 + 3 * aL + 3 * j] - xD)\r\n                    I_G = popt[2 + 3 * aL + 3 * j]\r\n                    pos_G = popt[1 + 3 * aL + 3 * j]\r\n                    pos_G_err = perr[1 + 3 * aL + 3 * j]\r\n                else:\r\n                    pass\r\n\r\n            area_BWF = []\r\n            area_BWF_err = []\r\n            for j in range(aB):\r\n                area_BWF.append(\r\n                    Flam_B(popt[0], popt[4 * j + 3 * aLG + 1], popt[4 * j + 3 * aLG + 2], popt[4 * j + 3 * aLG + 3],\r\n                           popt[4 * j + 3 * aLG + 4]))\r\n                area_BWF_err.append(DeltaFlam_B(popt[0], perr[0], popt[4 * j + 3 * aLG + 1], perr[4 * j + 3 * aLG + 1],\r\n                                                popt[4 * j + 3 * aLG + 2], perr[4 * j + 3 * aLG + 2],\r\n                                                popt[4 * j + 3 * aLG + 3], perr[4 * j + 3 * aLG + 3],\r\n                                                popt[4 * j + 3 * aLG + 4], perr[4 * j + 3 * aLG + 4]))\r\n                if np.abs(popt[4 * j + 3 * aLG + 1] - xD) < absxD:\r\n                    area_D = area_BWF[j]\r\n                    area_D_err = area_BWF_err[j]\r\n                    absxD = np.abs(popt[4 * j + 3 * aLG + 1] - xD)\r\n                    I_D = popt[4 * j + 3 * aLG + 2]\r\n                elif np.abs(popt[4 * j + 3 * aLG + 1] - xG) < absxG:\r\n                    area_G = area_BWF[j]\r\n                    area_G_err = area_BWF_err[j]\r\n                    absxG = np.abs(popt[4 * j + 3 * aLG + 1] - xD)\r\n                    I_G = popt[4 * j + 3 * aLG + 2]\r\n                    pos_G = popt[4 * j + 3 * aLG + 1]\r\n                    pos_G_err = perr[4 * j + 3 * aLG + 1]\r\n                    b_G = popt[4 * j + 3 * aLG + 3]\r\n                    q_G = popt[4 * j + 3 * aLG + 4]\r\n                else:\r\n                    pass\r\n\r\n            # Estimate Cluster size\r\n            # ID/IG = C(lambda)/L_a\r\n            # mit C(514.5 nm) = 44 Angstrom\r\n\r\n            L_a = 4.4 * area_G / area_D\r\n            L_a_err = L_a * (area_D_err / area_D + area_G_err / area_G)\r\n            area_ratio = area_D / area_G\r\n            area_ratio_err = area_ratio * (area_D_err / area_D + area_G_err / area_G)\r\n            ratio = I_D / I_G\r\n            ratio_err = 0\r\n\r\n            # get data into printable form\r\n            print_table = [['Background', popt[0], perr[0]]]\r\n            print_table.append(['', '', ''])\r\n            for j in range(aL):\r\n                print_table.append(['Lorentz %i' % (j + 1)])\r\n                print_table.append(['Raman Shift in cm-1', popt[j * 3 + 1], perr[j * 3 + 1]])\r\n                print_table.append(['Peak height in cps', popt[j * 3 + 2], perr[j * 3 + 2]])\r\n                print_table.append(['FWHM in cm-1', popt[j * 3 + 3], perr[j * 3 + 3]])\r\n                print_table.append(['Peak area in cps*cm-1', area_Lorentz[j], area_Lorentz_err[j]])\r\n                print_table.append(['', '', ''])\r\n            for j in range(aG):\r\n                print_table.append(['Gauss %i' % (j + 1)])\r\n                print_table.append(['Raman Shift in cm-1', popt[j * 3 + 3 * aL + 1], perr[j * 3 + 3 * aL + 1]])\r\n                print_table.append(['Peak height in cps', popt[j * 3 + 3 * aL + 2], perr[j * 3 + 3 * aL + 2]])\r\n                print_table.append(['FWHM in cm-1', popt[j * 3 + 3 * aL + 3], perr[j * 3 + 3 * aL + 3]])\r\n                print_table.append(['Peak area in cps*cm-1', area_Gauss[j], area_Gauss_err[j]])\r\n                print_table.append(['', '', ''])\r\n            for j in range(aB):\r\n                print_table.append(['BWF %i' % (j + 1)])\r\n                print_table.append(['Raman Shift in cm-1', popt[j * 3 + 3 * aLG + 1], perr[j * 3 + 3 * aLG + 1]])\r\n                print_table.append(['Peak height in cps', popt[j * 3 + 3 * aLG + 2], perr[j * 3 + 3 * aLG + 2]])\r\n                print_table.append(['FWHM in cm-1', popt[j * 3 + 3 * aLG + 3], perr[j * 3 + 3 * aLG + 3]])\r\n                print_table.append(['BWF Coupling Coefficient', popt[j * 3 + 3 * aLG + 4], perr[j * 3 + 3 * aLG + 4]])\r\n                print_table.append(['Peak area in cps*cm-1', area_BWF[j], area_BWF_err[j]])\r\n                print_table.append(['', '', ''])\r\n\r\n            print_table.append(['Cluster Size in nm', L_a, L_a_err])\r\n            print_table.append(['I_D/I_G', ratio, ratio_err])\r\n\r\n            save_data = r'R^2=%.6f \\n' % r_squared + 'Lorentz 1 = D-Bande, BWF (Breit-Wigner-Fano) 1 = G-Bande \\n' + tabulate(\r\n                print_table, headers=['Parameters', 'Values', 'Errors'])\r\n            print('\\n')\r\n            print(self.data[n][\"line\"].get_label())\r\n            print(save_data)\r\n\r\n            (fileBaseName, fileExtension) = os.path.splitext(self.data[n][\"line\"].get_label())\r\n            startFileDirName = os.path.dirname(self.selectedData[0][3])\r\n            with open(startFileDirName + \"/ID-IG.txt\", \"a\") as file_cluster:\r\n                file_cluster.write('\\n' + str(fileBaseName) + '   %.4f' % ratio + '   %.4f' % ratio_err)\r\n\r\n            pos_G_max = pos_G + b_G / (2 * q_G)\r\n            with open(startFileDirName + \"/G-Position.txt\", \"a\") as file_GPosition:\r\n                file_GPosition.write('\\n{} {:.4f}  {:.4f}'.format(fileBaseName, pos_G_max, 0.0))\r\n\r\n            # Save the fit parameter\r\n            startFileBaseName = startFileDirName + '/' + fileBaseName\r\n            startFileName = startFileBaseName + '_fitpara.txt'\r\n            # self.save_to_file('Save fit parameter in file', startFileName, save_data)\r\n\r\n            # Save the Fit data\r\n            startFileName = startFileBaseName + '_fitdata.txt'\r\n            save_data = [x1]\r\n            for j in y_L:\r\n                save_data.append(j)\r\n            for j in y_G:\r\n                save_data.append(j)\r\n            for j in y_BWF:\r\n                save_data.append(j)\r\n            save_data.append(y_Ges)\r\n            save_data = np.transpose(save_data)\r\n            # self.save_to_file('Save fit data in file', startFileName, save_data)\r\n\r\n    def norm_to_water(self):\r\n        \"\"\"\r\n        performs baseline correction on data with Doubly Reweighted Penalized Least Squares and lambda=9000000\r\n        and then normalizes the spectra to the water peak\r\n        \"\"\"\r\n        self.SelectDataset()\r\n        for n in self.selectedDatasetNumber:\r\n            # get data\r\n            xs = self.data[n][\"x\"]\r\n            ys = self.data[n][\"y\"]\r\n\r\n            # background correction\r\n            yb, baseline = self.blc.drPLS(xs, ys, lam=9000000)\r\n\r\n            # norm spectrum regarding water peak\r\n            norm_factor = np.max(yb[np.argwhere((xs>3000) & (xs<3700))])\r\n            yb = yb / norm_factor\r\n            self.data[n][\"y\"] = yb\r\n            self.data[n][\"line\"].set_data(xs, yb)\r\n            self.canvas.draw()\r\n            # Save normalized data\r\n            if self.data[n][\"filename\"] is not None:\r\n                (fileBaseName, fileExtension) = os.path.splitext(self.data[n][\"label\"])\r\n                startFileDirName = os.path.dirname(self.data[n][\"filename\"])\r\n                startFileBaseName = startFileDirName + '/' + fileBaseName\r\n                startFileName = startFileBaseName + '_norm.txt'\r\n            else:\r\n                startFileName = None\r\n            save_data = [self.data[n][\"x\"], self.data[n][\"y\"]]\r\n            save_data = np.transpose(save_data)\r\n            self.save_to_file('Save normalized data in file', startFileName, save_data)\r\n\r\n    def fit_sulfuroxyanion(self):\r\n        \"\"\"function to fit region between 700 and 1400cm-1 in spectra with sulfuroxyanions with Lorentzians\"\"\"\r\n        # select spectra, which should be fitted\r\n        self.SelectDataset()\r\n\r\n        # limit for fit region\r\n        x_min, x_max = [700, 1400]\r\n\r\n        # lists with positions and FWHM of all peaks in the fit region\r\n        # positions and FWHM of Persulfate (S_2O_8^2-) peaks\r\n        pos_PS = [802, 835, 1075]\r\n        fwhm_PS = [25, 15, 7]\r\n        # positions and FWHM of Caros acid (HSO_5^-)peaks\r\n        pos_Caros = [767, 884, 1057]\r\n        fwhm_Caros = [15, 15, 10]\r\n        # other peaks\r\n        peak_pos = [900, 982, 1030, 1045, 1190, 1256, 1291]\r\n        peak_fwhm = [25, 30, 15, 15, 55, 55, 35]\r\n        peak_pos.extend(pos_PS+pos_Caros)\r\n        peak_fwhm.extend(fwhm_PS+fwhm_Caros)\r\n\r\n        # sort list according to peak positions\r\n        peak_pos = sorted(peak_pos)\r\n        peak_fwhm = [f for _, f in sorted(zip(peak_pos, peak_fwhm))]\r\n\r\n        # number of fit functions\r\n        self.fit_functions.n_fit_fct['Lorentz'] = len(peak_pos)\r\n\r\n        for n in self.selectedDatasetNumber:\r\n            peak_areas = []\r\n\r\n            # get data\r\n            spct = self.data[n][\"line\"]\r\n            xs = spct.get_xdata()\r\n            ys = spct.get_ydata()\r\n\r\n            # limit data\r\n            y = ys[np.where((xs > x_min) & (xs < x_max))]\r\n            x = xs[np.where((xs > x_min) & (xs < x_max))]\r\n\r\n            # Fit parameter: initial guess and boundaries\r\n            p_start = [0]\r\n            p_bounds_low = [-0.001]\r\n            p_bounds_up = [np.inf]\r\n            for (start_pos, start_width) in zip(peak_pos, peak_fwhm):\r\n                start_height = max(y[np.where((x > (start_pos-3)) & (x < (start_pos+3)))])*0.9\r\n                if start_height < 0:\r\n                    start_height = 0\r\n                start_width = 15\r\n                p_start.extend([start_pos, start_height, start_width])\r\n                p_bounds_low.extend([start_pos-10, 0, 0])\r\n                p_bounds_up.extend([start_pos+10, np.inf, np.inf])\r\n            p_bounds = [p_bounds_low, p_bounds_up]\r\n\r\n            try:\r\n                popt, pcov = curve_fit(self.functions.FctSumme, x, y, p0=p_start, bounds=p_bounds, absolute_sigma=False)\r\n            except RuntimeError as e:\r\n                self.mw.show_statusbar_message(str(e), 4000)\r\n                continue\r\n\r\n            # Plot the Fit Data\r\n            x_fit = np.linspace(x_min, x_max, 3000)\r\n            for j in range(self.fit_functions.n_fit_fct['Lorentz']):\r\n                y_Lorentz = self.functions.LorentzFct(x_fit, popt[1 + 3 * j], popt[2 + 3 * j], popt[3 + 3 * j])\r\n                peak_areas.append(np.trapz(y_Lorentz))\r\n                self.ax.plot(x_fit, popt[0] + y_Lorentz, '--g')\r\n            self.ax.plot(x_fit, self.functions.FctSumme(x_fit, *popt), '-r')\r\n            self.canvas.draw()\r\n\r\n            # Calculate Errors and R square\r\n            perr = np.sqrt(np.diag(pcov))\r\n\r\n            residuals = y - self.functions.FctSumme(x, *popt)\r\n            ss_res = np.sum(residuals ** 2)\r\n            ss_tot = np.sum((y - np.mean(y)) ** 2)\r\n            r_squared = 1 - (ss_res / ss_tot)\r\n\r\n            # store fitparameter in table\r\n            print_table = [['Background', popt[0], perr[0]], ['', '', '']]\r\n            for j in range(self.fit_functions.n_fit_fct['Lorentz']):\r\n                print_table.append(['Lorentz %i' % (j + 1)])\r\n                print_table.append(['Raman Shift in cm-1', popt[j * 3 + 1], perr[j * 3 + 1]])\r\n                print_table.append(['Peak height in cps', popt[j * 3 + 2], perr[j * 3 + 2]])\r\n                print_table.append(['FWHM in cm-1', popt[j * 3 + 3], perr[j * 3 + 3]])\r\n                print_table.append(['Peak area in cps*cm-1', peak_areas[j], ''])\r\n                print_table.append(['', '', ''])\r\n            fit_parameter_table = tabulate(print_table, headers=['Parameters', 'Values', 'Errors'])\r\n\r\n            # print fitparameter\r\n            print('\\n')\r\n            print(self.data[n][\"line\"].get_label(), \"R^2={}\".format(r_squared))\r\n            print(fit_parameter_table)\r\n\r\n            # save the fit parameter\r\n            directory_name, file_name_spectrum = os.path.split(self.selectedData[n][3])\r\n            (fileBaseName, fileExtension) = os.path.splitext(file_name_spectrum)\r\n            file_name_parameter = '{}/{}_fitparameter.txt'.format(directory_name, fileBaseName)\r\n            self.save_to_file('Save fit parameter in file', file_name_parameter, fit_parameter_table)\r\n\r\n            # get peak heights of persulfate and CarosAcid peaks\r\n            name = self.data[n][\"line\"].get_label()\r\n            idx_PS = [peak_pos.index(p) for p in pos_PS]\r\n            idx_Caros = [peak_pos.index(p) for p in pos_Caros]\r\n            for j in idx_PS:\r\n                with open(\"{}/PS_intensity_PS{}cm-1.txt\".format(directory_name, peak_pos[j]), \"a\") as f:\r\n                    f.write('\\n{} {:.4f}  {:.4f}'.format(name, popt[3*j+2], perr[3*j+2]))\r\n\r\n            for j in idx_Caros:\r\n                with open(\"{}/PS_intensity_Caros{}cm-1.txt\".format(directory_name, peak_pos[j]), \"a\") as f:\r\n                    f.write('\\n{} {:.4f}  {:.4f}'.format(name, popt[3 * j + 2], perr[3 * j + 2]))\r\n\r\n        self.fit_functions.n_fit_fct['Lorentz'] = 0\r\n\r\n    def open_peakdatabase(self):\r\n        peak_database_dialog = database_spectra.DatabasePeakPosition()\r\n        peak_database_dialog.setMinimumWidth(600)\r\n        peak_database_dialog.show()\r\n        # wait until QMainWindow is closes\r\n        loop = QtCore.QEventLoop()\r\n        peak_database_dialog.closeSignal.connect(loop.quit)\r\n        peak_database_dialog.plot_peak_position_signal.connect(self.draw_peak_positions)\r\n        peak_database_dialog.remove_peak_position_signal.connect(self.remove_peak_positions)\r\n        loop.exec_()\r\n\r\n        # remove vertical lines (Line2D) in plot\r\n        for pp in self.peak_positions.values():\r\n            for v_line in pp:\r\n                v_line.remove()\r\n                del v_line\r\n        self.peak_positions = {}\r\n        self.canvas.draw()\r\n\r\n    def draw_peak_positions(self, peak_positions, id, n_materials):\r\n        colors = list(mcolors.BASE_COLORS)\r\n        pp_list = []\r\n        for pp in peak_positions:\r\n            v_line = self.ax.axvline(x=pp, color=colors[n_materials])\r\n            pp_list.append(v_line)\r\n        self.peak_positions[id] = pp_list\r\n        self.canvas.draw()\r\n\r\n    def remove_peak_positions(self, id):\r\n        if id in self.peak_positions.keys():\r\n            for v_line in self.peak_positions[id]:\r\n                v_line.remove()\r\n                del v_line\r\n            del self.peak_positions[id]\r\n        elif id == -1:\r\n            for pp in self.peak_positions.values():\r\n                for v_line in pp:\r\n                    v_line.remove()\r\n                    del v_line\r\n            self.peak_positions = {}\r\n        else:\r\n            return\r\n        self.canvas.draw()\r\n\r\n    # Functions of toolbar\r\n    def create_vertical_line(self):\r\n        if self.vertical_line is not None:\r\n            try:\r\n                self.vertical_line.remove_line()\r\n            except:\r\n                pass\r\n\r\n            self.vertical_line = None\r\n        else:\r\n            y_min, y_max = self.ax.get_ylim()\r\n            x_min, x_max = self.ax.get_xlim()\r\n            self.vertical_line = LineBuilder([(x_min + x_max) / 2, (x_min + x_max) / 2], [y_min, y_max], self.canvas,\r\n                                             parent=self)\r\n\r\n    def remove_vertical_line(self):\r\n        self.VertLineAct.setChecked(False)\r\n        self.vertical_line = None\r\n\r\n    def scale_spectrum(self):\r\n        self.SelectDataset(True)\r\n        for n in self.selectedDatasetNumber:\r\n            try:\r\n                ms = MoveSpectra(self.data[n][\"line\"], scaling=True)\r\n            except RuntimeError as e:\r\n                print(e)\r\n                continue\r\n            self.data[n][\"line\"] = ms.line\r\n            self.data[n][\"y\"] = ms.y\r\n\r\n    def shift_spectrum(self):\r\n        self.SelectDataset(True)\r\n        for n in self.selectedDatasetNumber:\r\n            try:\r\n                ms = MoveSpectra(self.data[n][\"line\"])\r\n            except RuntimeError as e:\r\n                print(e)\r\n                continue\r\n            self.data[n][\"line\"] = ms.line\r\n            self.data[n][\"y\"] = ms.y\r\n\r\n    def draw_line(self):\r\n        self.selected_points = []\r\n        self.pick_arrow_points_connection = self.canvas.mpl_connect('button_press_event', self.pick_points_for_arrow)\r\n\r\n    def pick_points_for_arrow(self, event):\r\n        self.selected_points.append([event.xdata, event.ydata])\r\n        if len(self.selected_points) == 2:\r\n            self.canvas.mpl_disconnect(self.pick_arrow_points_connection)\r\n            posA = self.selected_points[0]\r\n            posB = self.selected_points[1]\r\n\r\n            arrow = mpatches.FancyArrowPatch(posA, posB, mutation_scale=10, arrowstyle='-', picker=50)\r\n            arrow.set_figure(self.fig)\r\n            self.ax.add_patch(arrow)\r\n            self.drawn_line.append(LineDrawer(arrow))\r\n            self.canvas.draw()\r\n\r\n    def insert_text(self):\r\n        self.pick_text_point_connection = self.canvas.mpl_connect('button_press_event', self.pick_point_for_text)\r\n\r\n    def pick_point_for_text(self, event):\r\n        pos = [event.xdata, event.ydata]\r\n        text = self.ax.annotate(r'''*''', pos, picker=True, fontsize=24)\r\n        self.inserted_text.append(InsertText(text, self.mw))\r\n        self.canvas.mpl_disconnect(self.pick_text_point_connection)\r\n        self.canvas.draw()\r\n\r\n    def closeEvent(self, event):\r\n        close = QMessageBox()\r\n        close.setWindowTitle('Quit')\r\n        close.setText(\"You sure?\")\r\n        close.setStandardButtons(QMessageBox.Yes | QMessageBox.Cancel)\r\n        close = close.exec_()\r\n\r\n        if close == QMessageBox.Yes:\r\n            self.closeWindowSignal.emit('Plotwindow', self.windowTitle())\r\n            event.accept()\r\n        else:\r\n            event.ignore()\r\n\r\n\r\ndef new_MainWindow():\r\n    MW = MainWindow()\r\n    MW.showMaximized()\r\n    MW.load()\r\n\r\n\r\ndef main():\r\n    app = QApplication(sys.argv)\r\n    MW = MainWindow()\r\n    MW.showMaximized()\r\n    sys.exit(app.exec_())\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/PyRaman.py b/src/PyRaman.py
--- a/src/PyRaman.py	(revision 3e958476801d54abaaf1319f9f3d68f84c9865f6)
+++ b/src/PyRaman.py	(date 1662028194811)
@@ -492,22 +492,26 @@
                     ec = mcolors.to_hex(mcolors.to_rgba(line.get_markeredgecolor(), alpha), keep_alpha=True)
                     fc = mcolors.to_hex(mcolors.to_rgba(line.get_markerfacecolor(), alpha), keep_alpha=True)
                     curvedata = {
-                        'line style': line.get_linestyle(),
-                        'draw style': line.get_drawstyle(),
-                        'line width': line.get_linewidth(),
-                        'color': color,
-                        'marker style': line.get_marker(),
-                        'marker size': line.get_markersize(),
-                        'marker face color': fc,
-                        'marker edge color': ec}
+                        "line style": line.get_linestyle(),
+                        "draw style": line.get_drawstyle(),
+                        "line width": line.get_linewidth(),
+                        "color": color,
+                        "marker style": line.get_marker(),
+                        "marker size": line.get_markersize(),
+                        "marker face color": fc,
+                        "marker edge color": ec}
                     window_data[i]["line options"] = curvedata
 
         # get styles for errorbars
         for container in ax1.containers:
             if type(container) == matplotlib.container.ErrorbarContainer:
                 plotline, caplines, barlinecols = container
-                idx = [window.data.index(wd) for wd in window.data if plotline == wd["line"]]
-
+                try:
+                    idx = [window.data.index(wd) for wd in window.data if plotline == wd["line"]]
+                except KeyError as e:
+                    print(e)
+                    print(window.data)
+                    continue
                 error_color = mcolors.to_hex(
                     mcolors.to_rgba(caplines[0].get_markerfacecolor(), barlinecols[0].get_alpha()), keep_alpha=True)
                 window_data[idx[0]]["line options"]["error bar cap size"] = caplines[0].get_markersize()
@@ -745,15 +749,18 @@
                                                             picker=True, pickradius=5, capsize=3,
                                                             label="_Hidden errorbar {}".format(d["label"]))
                 spect.set_label(d["label"])
-                if "error bar line width" in d["line options"].keys():
-                    dlo = d["line options"]
-                    for capline in caplines:
-                        capline.set_markersize(dlo["error bar cap size"])
-                        capline.set_markeredgewidth(dlo["error bar line width"])
-                        capline.set_markerfacecolor(dlo["error bar color"])
-                        capline.set_markeredgecolor(dlo["error bar color"])
-                    barlinecol[0].set_linewidth(dlo["error bar line width"])
-                    barlinecol[0].set_color(dlo["error bar color"])
+                if "line options" in d.keys():
+                    if "error bar line width" in d["line options"].keys():
+                        dlo = d["line options"]
+                        for capline in caplines:
+                            capline.set_markersize(dlo["error bar cap size"])
+                            capline.set_markeredgewidth(dlo["error bar line width"])
+                            capline.set_markerfacecolor(dlo["error bar color"])
+                            capline.set_markeredgecolor(dlo["error bar color"])
+                        barlinecol[0].set_linewidth(dlo["error bar line width"])
+                        barlinecol[0].set_color(dlo["error bar color"])
+                else:
+                    print("no line options")
 
             else:
                 try:
@@ -2863,7 +2870,11 @@
                 self.methods[self.blcm.current_method]["parameter"]["roi"] = self.sort_roi(
                     self.methods[self.blcm.current_method]["parameter"]["roi"])
                 continue
-            self.methods[self.blcm.current_method]["parameter"][key] = float(val.text())
+            try:
+                self.methods[self.blcm.current_method]["parameter"][key] = float(val.text())
+            except ValueError as e:
+                self.pw.mw.show_statusbar_message(e, 4000)
+                return
         return_value = self.methods[self.blcm.current_method]["function"](self.x, self.y, *params)
         if return_value is None:
             self.close()
